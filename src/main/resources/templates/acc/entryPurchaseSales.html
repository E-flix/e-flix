<html xmlns:th="http://www.thymeleaf.org" xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout" layout:decorate="~{common/layouts/default}">
<!-- ============================================
  - 작성자   : 김희정
  - 최초작성 : 2025-06-18
  - 설명     : 매입매출전표 화면
  -----------------------------------------------
  [ 변경 이력 ]
  - 2025-06-18 (김희정): title 및 내용 추가
  - 2025-06-20 (김희정): 임시 레이아웃
  - 2025-06-30 (김희정): ag-Grid 기반 매입매출전표 구현 (entry.html 참고)
  - 2025-07-01 (김희정): 등록 및 수정 기능 구현
  - 2025-07-07 (김희정): 구분 필터링 추가, F4 모달 추가
============================================ -->

<head>
  <title>매입매출전표</title>
  <style>
    .ag-theme-alpine .ag-row-even, 
    .ag-theme-alpine .ag-row-odd {
      background: white !important;
    }
    .ag-row-total .ag-cell {
      background-color: #fff3cd !important;
      color: #856404 !important;
      font-weight: bold !important;
    }
    .subtotal-row .ag-cell {
      background: #f3f6fa !important;
      font-weight: bold !important;
      text-align: center;
    }
    /* 상세 그리드 소계 행 스타일 */
    .detail-subtotal-row .ag-cell {
      background: #f3f6fa !important;
      font-weight: bold !important;
      text-align: center;
    }
    /* 같은 전표번호 강조 표시 */
    .ag-row-highlighted .ag-cell {
      background-color: #e3f2fd !important;
    }
    .ag-row-highlighted .ag-cell:first-child {
      border-left: 3px solid #2196f3 !important;
    }
    .ag-row-highlighted.ag-row-selected .ag-cell {
      background-color: #bbdefb !important;
    }
    /* 모든 AG Grid 헤더 중앙정렬 */
    .ag-header-cell .ag-header-cell-text {
      text-align: center !important;
      justify-content: center !important;
    }
    .ag-header-group-cell .ag-header-group-text {
      text-align: center !important;
      justify-content: center !important;
    }
    /* ag-Grid 셀 중앙 정렬 클래스 */
    .ag-cell-center {
      text-align: center !important;
      display: flex !important;
      align-items: center !important;
      justify-content: center !important;
    }
    /* ag-Grid 셀 우측 정렬 클래스 */
    .ag-cell-right {
      text-align: right !important;
      display: flex !important;
      align-items: center !important;
      justify-content: flex-end !important;
    }
    /* ag-Grid 셀 좌측 정렬 클래스 */
    .ag-cell-left {
      text-align: left !important;
      display: flex !important;
      align-items: center !important;
      justify-content: flex-start !important;
    }
  </style>
</head>
<div layout:fragment="content">
  <!-- 모달 불러오기 -->
  <div th:replace="acc/modal/modal :: modals"></div>
  
  <div class="w-100">
    <!-- 헤더 영역 -->
    <div class="d-flex justify-content-between align-items-center mb-2">
      <h3 class="mb-0">매입매출전표</h3>
      <div>
        <button class="btn btn-outline-secondary btn-sm" onclick="deleteSelectedRows()">삭제</button>
        <button class="btn btn-outline-secondary btn-sm" onclick="window.print()">인쇄</button>
      </div>
    </div>

    <!-- 날짜 필터 영역 -->
    <!-- 검색/필터 영역만 수정 -->
    <form class="row g-2 mb-2 align-items-end" method="get" action="/voucher/list">
      <div class="col-auto">
        <label class="form-label mb-0">일자</label>
        2025 년
        <input type="number" value="1" class="form-control form-control-sm d-inline-block" name="startMonth" style="width:45px;"> 월
        <input type="number" value="1" class="form-control form-control-sm d-inline-block" name="startDay" style="width:45px;"> 일 ~
        2025 년
        <input type="number" value="12" class="form-control form-control-sm d-inline-block" name="endMonth" style="width:45px;"> 월
        <input type="number" value="31" class="form-control form-control-sm d-inline-block" name="endDay" style="width:45px;"> 일
      </div>
      <div class="col-auto">
        <label class="form-label mb-0">구분</label>
        <select class="form-control form-control-sm d-inline-block" name="entryType" style="width:80px;">
          <option value="">전체</option>
          <option value="매입">매입</option>
          <option value="매출">매출</option>
        </select>
      </div>
      <!-- 오른쪽 정렬 안내 메시지 -->
      <div class="col text-end">
        <small class="text-muted">※ 코드에서 F4를 누르면 검색할 수 있습니다.</small>
      </div>
    </form>
    <!-- 메인 매입매출전표 그리드 -->
    <div class="grid-container mb-2" style="height:40vh;">
      <div id="purchaseSalesGrid" class="ag-theme-alpine" style="width:100%; height:100%;"></div>
    </div>

    <!-- 중간 상세정보 영역 -->
    <div class="mb-2" style="height:18.3vh;">
      <div id="detailGrid" class="ag-theme-alpine" style="width:100%; height:100%"></div>
    </div>

    <!-- 하단 매출/매입 그리드 영역 (분리된 파일) -->
    <div th:replace="~{acc/entryPurchaseSalesGrid :: entryPurchaseSalesGridFragment}"></div>
  </div>

  <script th:inline="javascript">
    // 공통 코드(과세유형) 매핑
    const code0H = /*[[${code0H}]]*/ [];
    const code0A = /*[[${code0A}]]*/ [];
    const code0G = /*[[${code0G}]]*/ [];
    let purchaseSalesGridApi = null;
    let detailGridApi = null;
    let allPurchaseSalesData = []; // 전체 데이터를 저장할 배열
    let highlightedEntryNumber = null;
    let arrowKeyDebounceTimer = null;
    let selectedMaster = null;  // 선택된 마스터 로우 저장
    let resizeEventRegistered = false;  // resize 이벤트 중복 등록 방지
    
    // 로그인 사용자 정보
    let loginUser = 'admin'; // 기본값, 실제로는 세션에서 가져와야 함
    
    // 매입매출전표용 신규 전표번호
    let psEntryNumber = 50001; // 기본값
    selectPSEntryNumber();
    
    // 매입매출전표용 신규 전표번호 조회 함수
    async function selectPSEntryNumber() {
      try {
        const response = await fetch('/acc/enps/enNo');
        psEntryNumber = await response.json();
      } catch (err) {
        console.error('매입매출전표 전표번호 조회 실패:', err);
        psEntryNumber = 50001; // 실패 시 기본값
      }
    }
    
    // 매입매출 데이터
    let purchaseSalesData = [];

    // 상세정보 데이터
    let detailData = [];

    // 빈 행 생성 함수
    function getEmptyRow() {
      const emptyRow = {
        entryDate: null, // 빈 상태로 초기화 (사용자가 직접 입력)
        month: null,     // 월 필드 추가
        day: null,       // 일 필드 추가
        entryNumber: null,
        transactionType: '',
        itemName: '',
        quantity: null,
        unitPrice: null,
        totalSupplyAmount: null,
        totalTaxAmount: null,
        totalAmount: null, // 합계 필드 추가
        partnerCode: '',
        partnerName: '',
        businessNumber: '',
        electronicType: '',
        resentmenType: '',
        debitAmount: null,
        creditAmount: null,
        description: ''
      };
      // 유니크한 ID 미리 할당
      emptyRow._emptyRowId = `empty_row_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      return emptyRow;
    }

    // 빈 행인지 확인하는 함수 (필수값: 월/일/유형/공급가액/코드)
    function isEmptyRow(rowData) {
      return !rowData.entryNumber && 
             (!rowData.month || !rowData.day || !rowData.transactionType || 
              !rowData.totalSupplyAmount || !rowData.partnerCode);
    }

    // 필수값이 모두 입력되었는지 확인하는 함수
    function validatePurchaseSalesRow(rowData) {
      return rowData.month && rowData.day && rowData.transactionType && 
             rowData.totalSupplyAmount && rowData.partnerCode;
    }

    // 매입매출전표 행 저장 함수
    async function savePurchaseSalesRow(rowData) {
      const isNew = !rowData.entryNumber;
      let method = isNew ? 'POST' : 'PUT';
      
      // 신규 저장 시 매입매출전표용 전표번호 할당
      if (isNew) {
        rowData.entryNumber = psEntryNumber;
        // 다음 전표번호를 위해 1 증가
        psEntryNumber++;
      }
      
      // transactionType에 따라 entryType 자동 결정
      let entryType = '매입매출'; // 기본값
      if (rowData.transactionType) {
        const transactionCode = parseInt(rowData.transactionType);
        if (!isNaN(transactionCode)) {
          if (transactionCode <= 50) {
            entryType = '매출';
          } else {
            entryType = '매입';
          }
        }
      }
      
      // 매입매출전표 마스터 데이터 구성
      const masterData = {
        entryNumber: rowData.entryNumber || 0,
        entryType: entryType, // transactionType에 따라 자동 설정
        entryDate: rowData.entryDate,
        entryStatus: 'a2',
        creator: loginUser, // 로그인한 사용자 정보 사용
        transactionType: rowData.transactionType,
        electronicType: rowData.electronicType || 'a2',
        totalSupplyAmount: rowData.totalSupplyAmount || 0,
        totalTaxAmount: rowData.totalTaxAmount || 0,
        totalAmount: rowData.totalAmount || ((rowData.totalSupplyAmount || 0) + (rowData.totalTaxAmount || 0)), // 합계가 없으면 자동 계산
        partnerCode: rowData.partnerCode,
        partnerName: rowData.partnerName,
        businessNumber: rowData.businessNumber,
        itemName: rowData.itemName,
        quantity: rowData.quantity,
        unitPrice: rowData.unitPrice,
        description: rowData.description
      };
      
      try {
        const response = await fetch('/acc/enps', {
          method: method,
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(masterData)
        });
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const savedData = await response.json();
        
        if (savedData && savedData.entryNumber) {
          // 저장된 데이터로 그리드 업데이트
          rowData.entryNumber = savedData.entryNumber;
          
          // 날짜 필드 업데이트
          if (savedData.entryDate) {
            const date = new Date(savedData.entryDate);
            rowData.month = date.getMonth() + 1;
            rowData.day = date.getDate();
            rowData.entryDate = savedData.entryDate;
          }
          
          // 저장된 금액 데이터 업데이트
          if (savedData.totalSupplyAmount !== undefined) {
            rowData.totalSupplyAmount = savedData.totalSupplyAmount;
          }
          if (savedData.totalTaxAmount !== undefined) {
            rowData.totalTaxAmount = savedData.totalTaxAmount;
          }
          if (savedData.totalAmount !== undefined) {
            rowData.totalAmount = savedData.totalAmount;
          } else {
            // 서버에서 합계가 오지 않은 경우 클라이언트에서 계산
            rowData.totalAmount = (rowData.totalSupplyAmount || 0) + (rowData.totalTaxAmount || 0);
          }
          
          // 그리드 새로 고침 (이벤트 발생 방지)
          if (purchaseSalesGridApi) {
            // 업데이트 중 플래그 설정하여 onCellValueChanged 이벤트 방지
            rowData._isUpdating = true;
            purchaseSalesGridApi.refreshCells({ force: true });
            // 짧은 딜레이 후 플래그 해제
            setTimeout(() => {
              delete rowData._isUpdating;
            }, 100);
            
            // 신규 저장 후 빈 행 확인 및 추가
            if (isNew) {
              setTimeout(() => {
                let hasEmptyRow = false;
                for (let i = 0; i < purchaseSalesGridApi.getDisplayedRowCount(); i++) {
                  const row = purchaseSalesGridApi.getDisplayedRowAtIndex(i)?.data;
                  if (row && isEmptyRow(row)) {
                    hasEmptyRow = true;
                    break;
                  }
                }
                if (!hasEmptyRow) {
                  const newEmptyRow = getEmptyRow();
                  purchaseSalesGridApi.applyTransaction({ add: [newEmptyRow] });
                }
              }, 200);
            }
          }
          

        }
      } catch (error) {
        console.error('매입매출전표 저장 실패:', error);
        alert((isNew ? "신규 저장" : "수정") + " 실패: " + error.message);
      }
    }

    // 선택된 행 삭제 함수
    async function deleteSelectedRows() {
      // 현재 포커스된 그리드를 결정합니다.
      let focusedGridApi = null;
      let gridType = '';

      if (purchaseSalesGridApi && purchaseSalesGridApi.getSelectedRows().length > 0) {
        focusedGridApi = purchaseSalesGridApi;
        gridType = 'master';
      } else if (detailGridApi && detailGridApi.getSelectedRows().length > 0) {
        focusedGridApi = detailGridApi;
        gridType = 'detail';
      }

      if (!focusedGridApi) {
        alert('삭제할 행을 선택해주세요.');
        return;
      }

      const selectedRows = focusedGridApi.getSelectedRows();
      if (selectedRows.length === 0) {
        alert('삭제할 행을 선택해주세요.');
        return;
      }

      // 소계 행은 삭제 대상에서 제외
      const dataRows = selectedRows.filter(row => !row.isSummary);
      if (dataRows.length === 0) {
        alert('데이터 행을 선택해주세요.');
        return;
      }

      if (!confirm(`선택된 ${dataRows.length}개의 항목을 삭제하시겠습니까?`)) {
        return;
      }

      try {
        if (gridType === 'master') {
          // 마스터 그리드 행 삭제
          const masterData = dataRows.map(row => ({ entryNumber: row.entryNumber })).filter(item => item.entryNumber);
          if (masterData.length === 0) {
            // 실제 데이터가 아닌 빈 행만 선택된 경우
            focusedGridApi.applyTransaction({ remove: dataRows });
            
            // 마스터 그리드에 빈 행이 없으면 추가
            setTimeout(() => {
              let hasEmptyRow = false;
              for (let i = 0; i < focusedGridApi.getDisplayedRowCount(); i++) {
                const row = focusedGridApi.getDisplayedRowAtIndex(i)?.data;
                if (row && isEmptyRow(row)) {
                  hasEmptyRow = true;
                  break;
                }
              }
              if (!hasEmptyRow) {
                const newEmptyRow = getEmptyRow();
                focusedGridApi.applyTransaction({ add: [newEmptyRow] });
              }
            }, 100);
            return;
          }

          const response = await fetch(`/acc/enps/del`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(masterData)
          });

          if (!response.ok) {
            throw new Error(`전표 삭제 실패: ${response.statusText}`);
          }
          
          // 그리드에서 삭제된 행 제거
          focusedGridApi.applyTransaction({ remove: dataRows });
          
          // 상세 그리드 초기화
          if (detailGridApi) {
            detailGridApi.setGridOption('rowData', []);
            currentDetailEntryNumber = null;
          }
          
          // 마스터 그리드에 빈 행이 없으면 추가
          setTimeout(() => {
            let hasEmptyRow = false;
            for (let i = 0; i < focusedGridApi.getDisplayedRowCount(); i++) {
              const row = focusedGridApi.getDisplayedRowAtIndex(i)?.data;
              if (row && isEmptyRow(row)) {
                hasEmptyRow = true;
                break;
              }
            }
            if (!hasEmptyRow) {
              const newEmptyRow = getEmptyRow();
              focusedGridApi.applyTransaction({ add: [newEmptyRow] });
            }
          }, 100);
          
          alert('선택한 전표가 삭제되었습니다.');

        } else if (gridType === 'detail') {
          // 상세 그리드 행 삭제
          const detailData = dataRows.map(row => ({ 
              entryNumber: row.entryNumber, 
              lineNumber: row.lineNumber 
          })).filter(item => item.lineNumber);

          if (detailData.length === 0) {
            // 실제 데이터가 아닌 빈 행만 선택된 경우
            focusedGridApi.applyTransaction({ remove: dataRows });
            
            // 상세 그리드에 빈 행이 없으면 추가
            setTimeout(() => {
              let hasEmptyRow = false;
              for (let i = 0; i < focusedGridApi.getDisplayedRowCount(); i++) {
                const row = focusedGridApi.getDisplayedRowAtIndex(i)?.data;
                if (row && isEmptyDetailRow(row)) {
                  hasEmptyRow = true;
                  break;
                }
              }
              if (!hasEmptyRow && selectedMaster && selectedMaster.entryNumber) {
                const newEmptyRow = getEmptyDetailRow();
                newEmptyRow.entryNumber = selectedMaster.entryNumber;
                
                // 소계 행이 있으면 그 위에 추가, 없으면 일반 추가
                const summaryRowIndex = findSummaryRowIndex();
                if (summaryRowIndex >= 0) {
                  focusedGridApi.applyTransaction({ 
                    add: [newEmptyRow], 
                    addIndex: summaryRowIndex 
                  });
                } else {
                  focusedGridApi.applyTransaction({ add: [newEmptyRow] });
                }
              }
            }, 100);
            return;
          }

          const response = await fetch(`/acc/enps/detail/del`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(detailData)
          });

          if (!response.ok) {
            throw new Error(`상세 항목 삭제 실패: ${response.statusText}`);
          }

          // 그리드에서 삭제된 행 제거
          focusedGridApi.applyTransaction({ remove: dataRows });
          
          // 상세 그리드에 빈 행이 없으면 추가
          setTimeout(() => {
            let hasEmptyRow = false;
            let validEmptyRowCount = 0;
            
            for (let i = 0; i < focusedGridApi.getDisplayedRowCount(); i++) {
              const row = focusedGridApi.getDisplayedRowAtIndex(i)?.data;
              if (row) {
                const isEmpty = isEmptyDetailRow(row);
                if (isEmpty) {
                  hasEmptyRow = true;
                  validEmptyRowCount++;
                }
              }
            }
            
            // 빈 행이 없고 선택된 마스터가 있으면 빈 행 추가
            // 또는 유효한 빈 행이 없는 경우도 추가
            if ((!hasEmptyRow || validEmptyRowCount === 0) && selectedMaster && selectedMaster.entryNumber) {
              const newEmptyRow = getEmptyDetailRow();
              newEmptyRow.entryNumber = selectedMaster.entryNumber;
              
              // 소계 행이 있으면 그 위에 추가, 없으면 일반 추가
              const summaryRowIndex = findSummaryRowIndex();
              
              if (summaryRowIndex >= 0) {
                focusedGridApi.applyTransaction({ 
                  add: [newEmptyRow], 
                  addIndex: summaryRowIndex 
                });
              } else {
                focusedGridApi.applyTransaction({ add: [newEmptyRow] });
              }
            }
            
            // 빈 행 추가 후 소계 재계산
            if (selectedMaster && selectedMaster.entryNumber) {
              addDetailSummaryRow(selectedMaster.entryNumber);
            }
          }, 100);
          alert('선택한 상세항목이 삭제되었습니다.');
        }
      } catch (error) {
        console.error('삭제 처리 중 오류 발생:', error);
        alert('삭제 실패: ' + error.message);
      }
    }

    // 상세정보용 빈 행 생성 함수
    function getEmptyDetailRow() {
      const emptyRow = {
        entryNumber: null,  // 이후에 선택된 마스터의 전표번호로 설정됨
        resentmenType: '',
        accountCode: '',
        accountName: '',
        partnerCode: '',
        partnerName: '',
        debitAmount: null,
        creditAmount: null,
        description: '',
        lineNumber: null
      };
      emptyRow._emptyRowId = `empty_detail_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      return emptyRow;
    }

    // 상세정보 빈 행인지 확인하는 함수
    function isEmptyDetailRow(rowData) {
      // 소계 행은 빈 행이 아님
      if (rowData.isSummary === true) {
        return false;
      }
      
      // lineNumber가 없고, resentmenType과 accountCode가 모두 비어있어야 함
      const isEmpty = !rowData.lineNumber && 
                      (!rowData.resentmenType || rowData.resentmenType === '') && 
                      (!rowData.accountCode || rowData.accountCode === '') &&
                      // entryNumber가 유효한 번호여야 함 (빈 문자열이나 null이면 안됨)
                      rowData.entryNumber && 
                      typeof rowData.entryNumber === 'number' && 
                      rowData.entryNumber > 0;
                      
      return isEmpty;
    }

    // 상세 그리드 소계 행 생성 함수
    function generateDetailSummaryRow(entryNumber) {
      if (!detailGridApi || !entryNumber) return null;
      
      let debitTotal = 0;
      let creditTotal = 0;
      
      // 현재 그리드의 데이터에서 해당 전표번호의 합계 계산
      detailGridApi.forEachNode(node => {
        const data = node.data;
        if (data && !data.isSummary && data.entryNumber === entryNumber) {
          debitTotal += Number(data.debitAmount) || 0;
          creditTotal += Number(data.creditAmount) || 0;
        }
      });
      
      // 차액 계산
      const difference = Math.abs(debitTotal - creditTotal);
      
      return {
        entryNumber: '',
        resentmenType: '',
        accountCode: '',
        accountName: '',
        partnerCode: '',
        partnerName: '',
        debitAmount: debitTotal,
        creditAmount: creditTotal,
        description: '',
        lineNumber: null,
        isSummary: true,
        isSummaryType: 'subtotal',
        _summaryEntryNumber: entryNumber,
        _subtotalDiff: difference
      };
    }

    // 상세 그리드에서 기존 소계 행 제거
    function removeDetailSummaryRows() {
      if (!detailGridApi) return;
      
      const summaryRowsToRemove = [];
      detailGridApi.forEachNode(node => {
        if (node.data && node.data.isSummary === true) {
          summaryRowsToRemove.push(node.data);
        }
      });
      
      if (summaryRowsToRemove.length > 0) {
        detailGridApi.applyTransaction({ remove: summaryRowsToRemove });
      }
    }

    // 상세 그리드에 소계 행 추가 (항상 맨 마지막에 추가)
    function addDetailSummaryRow(entryNumber) {
      if (!detailGridApi || !entryNumber) return;
      
      // 기존 소계 행 제거
      removeDetailSummaryRows();
      
      // 새 소계 행 생성
      const summaryRow = generateDetailSummaryRow(entryNumber);
      if (summaryRow) {
        // 소계 행은 항상 맨 마지막에 추가
        detailGridApi.applyTransaction({ add: [summaryRow] });
      }
    }

    // 소계 행의 인덱스를 찾는 함수
    function findSummaryRowIndex() {
      if (!detailGridApi) return -1;
      
      for (let i = 0; i < detailGridApi.getDisplayedRowCount(); i++) {
        const rowNode = detailGridApi.getDisplayedRowAtIndex(i);
        if (rowNode && rowNode.data && rowNode.data.isSummary === true) {
          return i;
        }
      }
      return -1; // 소계 행이 없으면 -1 반환
    }

    // ag-Grid 로드 함수: master 리스트 가져오기
    async function loadMasterData() {
      try {
        const response = await fetch('/acc/enps/ma');
        const data = await response.json();
        
        // 기존 데이터에 month, day 필드 추가 및 합계 계산
        data.forEach(item => {
          if (item.entryDate) {
            const date = new Date(item.entryDate);
            item.month = date.getMonth() + 1;
            item.day = date.getDate();
          }
          
          // 합계가 없거나 0인 경우 공급가액 + 부가세로 계산
          if (!item.totalAmount || item.totalAmount === 0) {
            const supplyAmount = Number(item.totalSupplyAmount) || 0;
            const taxAmount = Number(item.totalTaxAmount) || 0;
            item.totalAmount = supplyAmount + taxAmount;
          }
        });

        allPurchaseSalesData = data; // 전체 데이터 저장


        applyDateFilter(); // 필터 적용하여 그리드 표시

        // 데이터 로드 후 합계 검증 및 보정
        setTimeout(() => {
          validateAndFixTotals();
        }, 200);

      } catch (err) {
        console.error('Master 리스트 로드 실패:', err);
      }
    }

    // 날짜 필터 함수
    function applyDateFilter() {
      if (!purchaseSalesGridApi) {
        console.warn('applyDateFilter: 그리드 API가 아직 준비되지 않았습니다.');
        return;
      }

      // 입력값 읽기
      const startMonth = Number(document.querySelector('input[name="startMonth"]').value);
      const startDay = Number(document.querySelector('input[name="startDay"]').value);
      const endMonth = Number(document.querySelector('input[name="endMonth"]').value);
      const endDay = Number(document.querySelector('input[name="endDay"]').value);
      const entryTypeFilter = document.querySelector('select[name="entryType"]').value; // 구분 필터 추가

      // 날짜 범위 계산 (월*100 + 일) -> 201 -> 2월 1일
      const start = startMonth && startDay ? (startMonth * 100 + startDay) : null;
      const end = endMonth && endDay ? (endMonth * 100 + endDay) : null;

      // allPurchaseSalesData 필터링
      const filteredData = allPurchaseSalesData.filter(row => {
        // 날짜 필터링
        if (!row.month || !row.day) return false; // 날짜 없는 데이터는 제외
        const md = row.month * 100 + row.day;
        if (start && md < start) return false;
        if (end && md > end) return false;
        
        // 구분 필터링 추가
        if (entryTypeFilter && entryTypeFilter !== '') {
          // transactionType 기반으로 매입/매출 구분
          if (row.transactionType) {
            const transactionCode = parseInt(row.transactionType);
            if (!isNaN(transactionCode)) {
              const rowEntryType = transactionCode <= 50 ? '매출' : '매입';
              if (rowEntryType !== entryTypeFilter) {
                return false;
              }
            }
          } else if (row.entryType && row.entryType !== entryTypeFilter) {
            // entryType 필드가 있는 경우 직접 비교
            return false;
          }
        }
        
        return true;
      });

      // 그리드에 반영
      purchaseSalesGridApi.setGridOption('rowData', filteredData);

      // 빈 행이 있는지 확인하고 없으면 추가
      let hasEmptyRow = false;
      purchaseSalesGridApi.forEachNode(node => {
        if (isEmptyRow(node.data)) {
          hasEmptyRow = true;
        }
      });

      if (!hasEmptyRow) {
        purchaseSalesGridApi.applyTransaction({ add: [getEmptyRow()] });
      }
    }

    // 현재 로드된 상세정보의 전표번호를 추적하는 변수
    let currentDetailEntryNumber = null;
    
    // 상세정보 표시 함수: 선택한 master의 detail 가져오기
    function showDetailInfo(master) {
      const entryNo = master.entryNumber;
      if (!entryNo) {
        // 빈 마스터 행인 경우 상세정보 그리드 초기화
        if (detailGridApi) {
          const current = [];
          detailGridApi.forEachNode(node => current.push(node.data));
          detailGridApi.applyTransaction({ remove: current });
          detailGridApi.setGridOption('rowData', []);
          currentDetailEntryNumber = null;
        }
        return;
      }
      
      // 같은 전표번호의 상세정보가 이미 로드되어 있으면 중복 호출 방지
      if (currentDetailEntryNumber === entryNo) {

        return;
      }
      

      currentDetailEntryNumber = entryNo;
      
      fetch(`/acc/enps/de/${entryNo}`)
        .then(res => {
          return res.json();
        })
        .then(data => {
          if (detailGridApi && typeof detailGridApi.applyTransaction === 'function') {
            // 기존 데이터 제거 후 새 데이터 추가

            
            // 금액 필드 처리: resentmenType과 amount 값에 따라 debitAmount 또는 creditAmount에 할당
            data.forEach(item => {
              // 기본값으로 차변/대변 모두 0으로 초기화
              item.debitAmount = 0;
              item.creditAmount = 0;
              

              if (item.amount !== undefined && item.amount !== null && item.amount !== 0) {
                // resentmenType에 따라 금액 배치
                if (item.resentmenType === 'g3') {
                  // g3은 차변 (양수든 음수든 차변에 절댓값으로)
                  item.debitAmount = Math.abs(item.amount);
                } else if (item.resentmenType === 'g4') {
                  // g4는 대변 (양수든 음수든 대변에 절댓값으로)
                  item.creditAmount = Math.abs(item.amount);
                } else {
                  // 기타 경우는 기존 로직 유지 (양수면 차변, 음수면 대변)
                  if (item.amount > 0) {
                    item.debitAmount = item.amount;
                  } else if (item.amount < 0) {
                    item.creditAmount = Math.abs(item.amount);
                  }
                }
              }
            });
            
            const current = [];
            detailGridApi.forEachNode(node => current.push(node.data));
            detailGridApi.applyTransaction({ remove: current, add: data });
            
            // 빈 행이 있는지 확인하고 없으면 추가
            setTimeout(() => {
              let hasEmptyRow = false;
              for (let i = 0; i < detailGridApi.getDisplayedRowCount(); i++) {
                const row = detailGridApi.getDisplayedRowAtIndex(i)?.data;
                if (row && isEmptyDetailRow(row)) {
                  hasEmptyRow = true;
                  break;
                }
              }
              if (!hasEmptyRow) {
                const newEmptyRow = getEmptyDetailRow();
                // 선택된 마스터의 전표번호를 빈 행에 설정
                newEmptyRow.entryNumber = master.entryNumber;
                
                // 소계 행이 있으면 그 위에 추가, 없으면 일반 추가
                const summaryRowIndex = findSummaryRowIndex();
                if (summaryRowIndex >= 0) {
                  detailGridApi.applyTransaction({ 
                    add: [newEmptyRow], 
                    addIndex: summaryRowIndex 
                  });
                } else {
                  detailGridApi.applyTransaction({ add: [newEmptyRow] });
                }
              }
              

              // 소계 행 추가
              addDetailSummaryRow(master.entryNumber);
            }, 100);
            
            detailGridApi.refreshCells({ force: true });
          } else {

          }
        })
        .catch(err => {

          currentDetailEntryNumber = null; // 오류 시 초기화
          // 오류 발생 시에도 빈 행 추가
          if (detailGridApi) {
            const current = [];
            detailGridApi.forEachNode(node => current.push(node.data));
            detailGridApi.applyTransaction({ remove: current });
            
            const newEmptyRow = getEmptyDetailRow();
            newEmptyRow.entryNumber = master.entryNumber;
            
            // 소계 행이 있으면 그 위에 추가, 없으면 일반 추가
            const summaryRowIndex = findSummaryRowIndex();
            if (summaryRowIndex >= 0) {
              detailGridApi.applyTransaction({ 
                add: [newEmptyRow], 
                addIndex: summaryRowIndex 
              });
            } else {
              detailGridApi.applyTransaction({ add: [newEmptyRow] });
            }
          }
        });
    }

    // 기존 데이터의 합계 검증 및 보정 함수
    function validateAndFixTotals() {
      if (!purchaseSalesGridApi) return;
      
      let needsRefresh = false;
      purchaseSalesGridApi.forEachNode(node => {
        const data = node.data;
        if (data && data.entryNumber) {
          const supplyAmount = Number(data.totalSupplyAmount) || 0;
          const taxAmount = Number(data.totalTaxAmount) || 0;
          const currentTotal = Number(data.totalAmount) || 0;
          const expectedTotal = supplyAmount + taxAmount;
          
          // 합계가 잘못되었거나 비어있는 경우 수정
          if (supplyAmount > 0 && currentTotal !== expectedTotal) {
            data.totalAmount = expectedTotal;
            needsRefresh = true;

          }
        }
      });
      
      if (needsRefresh) {
        purchaseSalesGridApi.refreshCells({ force: true });

      }
    }

    // 매입매출전표 그리드 설정
    const purchaseSalesGridOptions = {
      suppressClickEdit: true,
      singleClickEdit: false,
      headerHeight: 30,
      rowHeight: 28,
      getRowId: params => {
        const data = params.data;
        // 일반 데이터 행 (entryNumber로 고유 ID 생성)
        if (data && data.entryNumber) {
          return `entry_${data.entryNumber}`;
        }
        // 빈 행 (신규 행) 처리
        if (data) {
          // _emptyRowId가 없으면 새로 생성하여 할당
          if (!data._emptyRowId) {
            data._emptyRowId = `empty_row_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
          }
          return data._emptyRowId;
        }
        // 데이터가 없는 경우 기본 ID 반환
        return `fallback_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      },
      columnDefs: [
        { headerName: "월", field: "month", initialWidth: 75, cellClass: 'ag-cell-center', editable: true,
          valueSetter: params => {
            const month = Number(params.newValue);
            if (month >= 1 && month <= 12) {
              params.data.month = month;
              // 월과 일이 모두 있으면 entryDate 생성 (월은 1부터 시작하므로 -1 필요 없음)
              if (params.data.month && params.data.day) {
                // 2025-MM-DD 형식의 문자열로 직접 생성 (시간대 문제 방지)
                const monthStr = String(params.data.month).padStart(2, '0');
                const dayStr = String(params.data.day).padStart(2, '0');
                params.data.entryDate = `2025-${monthStr}-${dayStr}`;
              }
              return true;
            }
            return false;
          }
        },
        { 
          headerName: "일", field: "day", initialWidth: 75, cellClass: 'ag-cell-center', editable: true,
          valueSetter: params => {
            const day = Number(params.newValue);
            if (day >= 1 && day <= 31) {
              params.data.day = day;
              // 월과 일이 모두 있으면 entryDate 생성 (월은 1부터 시작하므로 -1 필요 없음)
              if (params.data.month && params.data.day) {
                // 2025-MM-DD 형식의 문자열로 직접 생성 (시간대 문제 방지)
                const monthStr = String(params.data.month).padStart(2, '0');
                const dayStr = String(params.data.day).padStart(2, '0');
                params.data.entryDate = `2025-${monthStr}-${dayStr}`;
              }
              return true;
            }
            return false;
          }
        },
        { headerName: "번호", field: "entryNumber", initialWidth: 120, editable: false },
        { headerName: "유형", field: "transactionType", initialWidth: 100, editable: true, cellRenderer: params => {
            const code = params.value;
            const mapping = code0H.find(item => item.commonCode === code);
            if (mapping) {
              const badgeColor = parseInt(mapping.commonCode) <= 50 ? 'bg-danger' : 'bg-primary';
              return `<span class="badge ${badgeColor}">${mapping.commonCodeName}</span>`;
            }
            return code || '';
          } },
        { headerName: "품명", field: "itemName", minWidth: 200, editable: true },
        { headerName: "수량", field: "quantity", initialWidth: 100, cellClass: 'ag-right-aligned-cell', 
          valueFormatter: params => {
            const value = params.value;
            if (value !== null && value !== undefined && value !== '') {
              return Number(value).toLocaleString();
            }
            return '';
          },
          editable: true,
          valueSetter: params => {
            const numValue = Number(params.newValue?.toString().replace(/,/g, ''));
            if (!isNaN(numValue) && numValue >= 0) {
              params.data.quantity = numValue;
              return true;
            }
            return false;
          }
        },
        { headerName: "단가", field: "unitPrice", minWidth: 100, cellClass: 'ag-right-aligned-cell', 
          valueFormatter: params => {
            const value = params.value;
            if (value !== null && value !== undefined && value !== '') {
              return Number(value).toLocaleString();
            }
            return '';
          },
          editable: true,
          valueSetter: params => {
            const numValue = Number(params.newValue?.toString().replace(/,/g, ''));
            if (!isNaN(numValue) && numValue >= 0) {
              params.data.unitPrice = numValue;
              return true;
            }
            return false;
          }
        },
        { headerName: "공급가액", field: "totalSupplyAmount", minWidth: 120, cellClass: 'ag-right-aligned-cell', 
          valueFormatter: params => {
            const value = params.value;
            if (value !== null && value !== undefined && value !== '') {
              return Number(value).toLocaleString();
            }
            return '';
          },
          editable: true,
          valueSetter: params => {
            const numValue = Number(params.newValue?.toString().replace(/,/g, ''));
            if (!isNaN(numValue) && numValue >= 0) {
              params.data.totalSupplyAmount = numValue;
              return true;
            }
            return false;
          }
        },
        { headerName: "부가세", field: "totalTaxAmount", minWidth: 100, cellClass: 'ag-right-aligned-cell', 
          valueFormatter: params => {
            const value = params.value;
            if (value !== null && value !== undefined && value !== '') {
              return Number(value).toLocaleString();
            }
            return '';
          },
          editable: true,
          valueSetter: params => {
            const numValue = Number(params.newValue?.toString().replace(/,/g, ''));
            if (!isNaN(numValue) && numValue >= 0) {
              params.data.totalTaxAmount = numValue;
              return true;
            }
            return false;
          }
        },
        { headerName: "합계", field: "totalAmount", minWidth: 120, cellClass: 'ag-right-aligned-cell', 
          valueFormatter: params => {
            const value = params.value;
            if (value !== null && value !== undefined && value !== '') {
              return Number(value).toLocaleString();
            }
            return '';
          },
          editable: true,
          valueSetter: params => {
            const numValue = Number(params.newValue?.toString().replace(/,/g, ''));
            if (!isNaN(numValue) && numValue >= 0) {
              params.data.totalAmount = numValue;
              return true;
            }
            return false;
          }
        },
        { headerName: "코드", field: "partnerCode", minWidth: 90, editable: true },
        { headerName: "공급처명", field: "partnerName", minWidth: 120, editable: true },
        { headerName: "등록번호", field: "businessNumber", minWidth: 150, editable: true },
        { headerName: "전자", field: "electronicType", minWidth: 50, editable: true, flex: 1,
            cellRenderer: params => { 
              const code = params.value;
              if (code === 'a1') { return '○'; } 
              else if (code === 'a2') { return ''; } 
              return code || '';
            },
            valueSetter: params => {
              const inputValue = params.newValue?.toString().trim();
              
              // 1 입력 시 a1으로 자동 변환
              if (inputValue === '1') {
                params.data.electronicType = 'a1';
                return true;
              }
              // 2 입력 시 a2로 자동 변환
              else if (inputValue === '2') {
                params.data.electronicType = 'a2';
                return true;
              }
              // 그 외에는 원래 값 그대로 설정
              else {
                params.data.electronicType = inputValue;
                return true;
              }
            }
        }
      ],
      rowSelection: { mode: 'multiRow' },
      onGridReady: (params) => {
        purchaseSalesGridApi = params.api;
        loadMasterData();

        // 날짜 필터 이벤트 리스너 등록
        ['startMonth', 'startDay', 'endMonth', 'endDay'].forEach(name => {
          document.querySelector(`input[name="${name}"]`).addEventListener('input', applyDateFilter);
        });

        // 구분 필터 이벤트 리스너 추가
        document.querySelector('select[name="entryType"]').addEventListener('change', applyDateFilter);

        // 컬럼 너비 자동맞춤
        params.api.sizeColumnsToFit();
        // 창 크기 변경 시 모든 그리드 자동맞춤 (한 번만 등록)
        if (!resizeEventRegistered) {
          window.addEventListener('resize', () => {
            if (purchaseSalesGridApi) purchaseSalesGridApi.sizeColumnsToFit();
            if (detailGridApi) detailGridApi.sizeColumnsToFit();
          });
          resizeEventRegistered = true;
        }
        
        // 빈 행 추가
        setTimeout(() => {
          let hasEmptyRow = false;
          for (let i = 0; i < params.api.getDisplayedRowCount(); i++) {
            const row = params.api.getDisplayedRowAtIndex(i)?.data;
            if (row && isEmptyRow(row)) {
              hasEmptyRow = true;
              break;
            }
          }
          if (!hasEmptyRow) {
            const newEmptyRow = getEmptyRow();
            params.api.applyTransaction({ add: [newEmptyRow] });
          }
        }, 100);
      },
      onRowClicked: (event) => {
        selectedMaster = event.data;  // 클릭된 마스터 저장
        // 등록된 마스터 행(전표번호가 있는 행)만 상세정보 표시
        if (event.data.entryNumber) {
          showDetailInfo(event.data);
        } else {
          // 빈 행 클릭 시 상세정보 그리드 초기화
          if (detailGridApi) {
            const current = [];
            detailGridApi.forEachNode(node => current.push(node.data));
            detailGridApi.applyTransaction({ remove: current });
          }
        }
      },
      onRowSelected: (event) => {
        // 행이 선택되었을 때만 다른 그리드의 선택을 해제합니다.
        if (event.node.isSelected() && detailGridApi) {
          detailGridApi.deselectAll();
        }
      },
      onCellFocused: (event) => {
        // 셀에 포커스가 맞춰질 때도 상세정보 표시 (단, 클릭이 아닌 키보드 이동 등의 경우만)
        if (event.rowIndex !== null && event.rowIndex >= 0) {
          const rowNode = purchaseSalesGridApi.getDisplayedRowAtIndex(event.rowIndex);
          if (rowNode && rowNode.data) {
            // 이미 같은 마스터가 선택되어 있으면 중복 호출 방지
            if (selectedMaster && selectedMaster.entryNumber === rowNode.data.entryNumber) {
              return;
            }
            
            selectedMaster = rowNode.data;
            if (rowNode.data.entryNumber) {
              showDetailInfo(rowNode.data);
            } else {
              // 빈 행 포커스 시 상세정보 그리드 초기화
              if (detailGridApi) {
                const current = [];
                detailGridApi.forEachNode(node => current.push(node.data));
                detailGridApi.applyTransaction({ remove: current });
              }
            }
          }
        }
      },
      onCellKeyDown: (event) => {
        const api = event.api;
        const currentRowIndex = event.node.rowIndex;
        const currentCol = event.colDef.field;
        const allColumns = purchaseSalesGridOptions.columnDefs;
        const currentColIndex = allColumns.findIndex(col => col.field === currentCol);
        
        // --------------- ▼ F4 모달 추가 ▼ ------------------
        if (event.event.key === 'F4') {
          if (currentCol === 'partnerCode') {
            // 거래처 모달 열기 - 콜백으로 값 설정
            openPartnerModal(currentRowIndex, (code, name) => {
              const node = api.getDisplayedRowAtIndex(currentRowIndex);
              if (node) {
                node.setDataValue('partnerCode', String(code));
                node.setDataValue('partnerName', String(name));
                
                // 거래처 정보 추가 조회하여 등록번호 설정
                fetch(`/acc/pt/${code}`)
                  .then(res => res.json())
                  .then(partner => {
                    if (partner) {
                      const registrationNumber = partner.businessNumber || partner.residentNumber || '';
                      node.setDataValue('businessNumber', registrationNumber);
                    }
                  })
                  .catch(err => console.error('거래처 정보 조회 실패:', err));
              }
            });
            event.event.preventDefault();
            return;
          }
        }
        // --------------- ▲ F4 모달 추가 ▲ ------------------
        
        // 기존 Enter 키 처리는 그대로 유지
        if (event.event.key === 'Enter') {
          event.event.preventDefault();
          event.event.stopPropagation();
          
          // API 유효성 검사
          if (!api || typeof api.getDisplayedRowCount !== 'function' || 
              typeof api.getDisplayedRowAtIndex !== 'function' ||
              typeof api.setFocusedCell !== 'function') {
            console.error('Enter 키 처리 시 API가 유효하지 않습니다.');
            return;
          }
          
          // 다음 editable 셀 찾기
          let nextColIndex = currentColIndex + 1;
          let nextRowIndex = currentRowIndex;
          
          while (true) {
            if (nextColIndex >= allColumns.length) {
              nextColIndex = 0;
              nextRowIndex++;
              if (nextRowIndex >= api.getDisplayedRowCount()) {
                // 마지막 행을 넘어가면 새 빈 행 추가
                const newEmptyRow = getEmptyRow();
                api.applyTransaction({ add: [newEmptyRow] });
                
                setTimeout(() => {
                  // 마지막 행(새로 추가된 행)에 포커스
                  const lastRowIndex = api.getDisplayedRowCount() - 1;
                  api.setFocusedCell(lastRowIndex, allColumns[0].field);
                }, 100);
                return;
              }
            }
            
            const nextRowNode = api.getDisplayedRowAtIndex(nextRowIndex);
            if (!nextRowNode || !nextRowNode.data) {
              nextColIndex++;
              continue;
            }
            
            let editable = false;
            if (typeof allColumns[nextColIndex].editable === 'function') {
              editable = allColumns[nextColIndex].editable({ data: nextRowNode.data });
            } else {
              editable = allColumns[nextColIndex].editable;
            }
            
            if (editable) {
              setTimeout(() => {
                api.setFocusedCell(nextRowIndex, allColumns[nextColIndex].field);
              }, 50);
              break;
            }
            nextColIndex++;
          }
          return;
        }
      },
      onCellValueChanged: async (event) => {
        const rowData = event.data;
        const changedField = event.colDef.field;
        
        // 무한 루프 방지를 위한 플래그 체크
        if (rowData._isCalculating || rowData._isUpdating) {
          return;
        }
        
        // 자동 계산 처리 (수량, 단가, 공급가액, 합계, 거래유형 변경 시)
        if (['quantity', 'unitPrice', 'totalSupplyAmount', 'totalAmount', 'transactionType'].includes(changedField)) {
          // 계산 중 플래그 설정
          rowData._isCalculating = true;
          
          performAutoCalculation(rowData, changedField);
          
          // 자동 계산된 값들을 그리드에 반영 (setDataValue 대신 직접 데이터 업데이트)
          if (['quantity', 'unitPrice', 'totalSupplyAmount', 'transactionType'].includes(changedField)) {
            // 데이터는 이미 performAutoCalculation에서 업데이트됨
          } else if (changedField === 'totalAmount') {
            // 데이터는 이미 performAutoCalculation에서 업데이트됨
          }
          
          // 계산 중 플래그 해제
          delete rowData._isCalculating;
          
          setTimeout(() => {
            if (purchaseSalesGridApi) {
              purchaseSalesGridApi.refreshCells({
                rowNodes: [event.node],
                columns: ['totalSupplyAmount', 'totalTaxAmount', 'totalAmount'],
                force: true
              });
            }
          }, 50);
        }
        
        // 거래처 코드 매핑 처리
        if (event.colDef.field === 'partnerCode') {
          const partnerCode = event.newValue;
          if (partnerCode && !isNaN(partnerCode)) {
            try {
              const response = await fetch(`/acc/pt/${partnerCode}`);
              if (response.ok) {
                const partner = await response.json();
                if (partner && partner.partnerName) {
                  // 공급처명 설정
                  event.node.setDataValue('partnerName', partner.partnerName);
                  
                  // 등록번호 설정 (사업자등록번호 우선, 없으면 주민등록번호)
                  const registrationNumber = partner.businessNumber || partner.residentNumber || '';
                  event.node.setDataValue('businessNumber', registrationNumber);
                } else {
                  event.node.setDataValue('partnerName', '');
                  event.node.setDataValue('businessNumber', '');
                  alert("해당 거래처를 찾을 수 없습니다.");
                }
              } else {
                event.node.setDataValue('partnerName', '');
                event.node.setDataValue('businessNumber', '');
                alert("거래처 조회 중 오류가 발생했습니다.");
              }
            } catch (error) {
              console.error('거래처 조회 오류:', error);
              event.node.setDataValue('partnerName', '');
              event.node.setDataValue('businessNumber', '');
              alert("서버와 통신 중 오류가 발생했습니다.");
            }
          } else if (!partnerCode) {
            // 거래처 코드가 비어있으면 관련 필드들도 초기화
            event.node.setDataValue('partnerName', '');
            event.node.setDataValue('businessNumber', '');
          }
        }
        
        // 필수값이 모두 채워지면 자동 저장 (저장 중이 아닐 때만)
        const currentRowData = event.data;
        
        // 필수값이 모두 입력되었는지 확인하고 저장 중이 아닐 때만 저장
        if (validatePurchaseSalesRow(currentRowData) && !currentRowData._isSaving) {
          // 저장 중 플래그 설정
          currentRowData._isSaving = true;
          
          // 자동 저장
          savePurchaseSalesRow(currentRowData).finally(() => {
            // 저장 완료 후 플래그 해제
            delete currentRowData._isSaving;
          });
        }
        
        // 셀 값이 변경될 때 빈 행이 있는지 확인하고 없으면 추가
        setTimeout(() => {
          let hasEmptyRow = false;
          for (let i = 0; i < event.api.getDisplayedRowCount(); i++) {
            const row = event.api.getDisplayedRowAtIndex(i)?.data;
            if (row && isEmptyRow(row)) {
              hasEmptyRow = true;
              break;
            }
          }
          if (!hasEmptyRow) {
            const newEmptyRow = getEmptyRow();
            event.api.applyTransaction({ add: [newEmptyRow] });
          }
        }, 50);
      }
    };

    // 상세정보 그리드 설정
    const detailGridOptions = {
      headerHeight: 28,
      rowHeight: 28,
      rowData: detailData,
      suppressHorizontalScroll: false,
      suppressClickEdit: true,
      singleClickEdit: false,
      rowSelection: { 
        mode: 'multiRow',
        enableClickSelection: true
      },
      selectionOptions: {
        isRowSelectable: (params) => {
          return !(params.data && params.data.isSummary === true);
        }
      },
      localeText: { noRowsToShow: '매입매출전표를 선택하면 해당 전표의 상세내용을 편집할 수 있습니다.' },
      getRowId: params => {
        const data = params.data;
        // 소계 행 처리
        if (data && data.isSummary === true) {
          return `detail_summary_${data._summaryEntryNumber || 'unknown'}_${data.isSummaryType || 'subtotal'}`;
        }
        // 일반 데이터 행
        if (data && data.entryNumber && data.lineNumber) {
          return `detail_${data.entryNumber}_${data.lineNumber}`;
        }
        // 빈 행 처리 - entryNumber가 있는 경우
        if (data && data.entryNumber && !data.lineNumber) {
          if (!data._emptyRowId) {
            data._emptyRowId = `empty_detail_${data.entryNumber}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
          }
          return data._emptyRowId;
        }
        // 완전히 빈 행 처리
        if (data) {
          if (!data._emptyRowId) {
            data._emptyRowId = `empty_detail_new_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
          }
          return data._emptyRowId;
        }
        // 데이터가 없는 경우 기본 ID 반환
        return `empty_row_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      },
      getRowClass: params => {
        // 소계 행 스타일 클래스 적용
        if (params.data && params.data.isSummary === true) {
          return 'detail-subtotal-row';
        }
        return '';
      },
      columnDefs: [
        { headerName: "일자", 
          cellRenderer: params => {
            // 소계 행인 경우 - 첫 번째 셀에서만 전표소계 표시
            if (params.data && params.data.isSummary === true) {
              return '전표소계';
            }
            if (!selectedMaster || !selectedMaster.entryDate) return '';
            const d = new Date(selectedMaster.entryDate);
            const mm = String(d.getMonth() + 1).padStart(2, '0');
            const dd = String(d.getDate()).padStart(2, '0');
            return `${mm}-${dd}`;
          }, minWidth: 80, cellClass: 'ag-cell-center',
          colSpan: params => {
            // 소계 행인 경우 5개 셀 합치기 (일자~계정과목)
            if (params.data && params.data.isSummary === true) {
              return 5;
            }
            return 1;
          },
          cellStyle: params => {
            // 소계 행인 경우 가운데 정렬
            if (params.data && params.data.isSummary === true) {
              return { 
                'text-align': 'center',
                'display': 'flex',
                'align-items': 'center',
                'justify-content': 'center'
              };
            }
            return null;
          }
        },
        { headerName: "전표번호", field: "entryNumber", minWidth: 100, editable: false,
          cellRenderer: params => {
            // 소계 행인 경우는 colSpan으로 인해 렌더링되지 않음
            return params.value || '';
          }
        },
        { headerName: "구분", field: "resentmenType", minWidth: 80, 
          editable: params => {
            // 소계 행은 편집 불가
            return !(params.data && params.data.isSummary === true);
          },
          cellRenderer: params => {
            // 소계 행인 경우는 colSpan으로 인해 렌더링되지 않음
            return code0G.find(v => String(v.commonCode) === String(params.value))?.commonCodeName || params.value || '';
          },
          valueSetter: params => {
            const inputValue = params.newValue?.toString().trim();
            
            // 3 입력 시 g3으로 자동 변환
            if (inputValue === '3') {
              params.data.resentmenType = 'g3';
              return true;
            }
            // 4 입력 시 g4로 자동 변환
            else if (inputValue === '4') {
              params.data.resentmenType = 'g4';
              return true;
            }
            // 그 외에는 원래 값 그대로 설정
            else {
              params.data.resentmenType = inputValue;
              return true;
            }
          }
        },
        { headerName: "코드", field: "accountCode", minWidth: 80, 
          editable: params => {
            // 소계 행은 편집 불가
            return !(params.data && params.data.isSummary === true);
          },
          cellRenderer: params => {
            // 소계 행인 경우는 colSpan으로 인해 렌더링되지 않음
            return params.value || '';
          }
        },
        { headerName: "계정과목", field: "accountName", minWidth: 120, 
          editable: false,
          cellRenderer: params => {
            // 소계 행인 경우는 colSpan으로 인해 렌더링되지 않음
            return params.value || '';
          }
        },
        { headerName: "코드", field: "partnerCode", minWidth: 80, 
          editable: params => {
            // 소계 행은 편집 불가
            return !(params.data && params.data.isSummary === true);
          },
          cellRenderer: params => {
            // 소계 행인 경우 '차액' 표시
            if (params.data && params.data.isSummary === true) {
              return '차액';
            }
            return params.value || '';
          }
        },
        { headerName: "거래처명", field: "partnerName", minWidth: 120, 
          editable: params => {
            // 소계 행은 편집 불가
            return !(params.data && params.data.isSummary === true);
          },
          cellRenderer: params => {
            // 소계 행인 경우 차액 금액 표시 (천단위 포맷)
            if (params.data && params.data.isSummary === true && params.data._subtotalDiff !== undefined) {
              return Number(params.data._subtotalDiff).toLocaleString();
            }
            return params.value || '';
          }
        },
        { headerName: "차변", field: "debitAmount", minWidth: 100, cellClass: 'ag-right-aligned-cell', 
          valueFormatter: params => {
            const value = params.value;
            if (value !== null && value !== undefined && value !== '' && value > 0) {
              return Number(value).toLocaleString();
            }
            return '';
          },
          editable: params => {
            // 소계 행이거나 g4이면 차변 입력 불가
            return !(params.data && params.data.isSummary === true) && params.data.resentmenType !== 'g4';
          },
          valueSetter: params => {
            // g4이면 차변 입력 불가
            if (params.data.resentmenType === 'g4') {
              return false;
            }
            const numValue = Number(params.newValue?.toString().replace(/,/g, ''));
            if (!isNaN(numValue) && numValue >= 0) {
              params.data.debitAmount = numValue;
              // 차변 입력 시 대변 초기화
              if (numValue > 0) {
                params.data.creditAmount = 0;
              }
              return true;
            }
            return false;
          }
        },
        { headerName: "대변", field: "creditAmount", minWidth: 100, cellClass: 'ag-right-aligned-cell', 
          valueFormatter: params => {
            const value = params.value;
            if (value !== null && value !== undefined && value !== '' && value > 0) {
              return Number(value).toLocaleString();
            }
            return '';
          },
          editable: params => {
            // 소계 행이거나 g3이면 대변 입력 불가
            return !(params.data && params.data.isSummary === true) && params.data.resentmenType !== 'g3';
          },
          valueSetter: params => {
            // g3이면 대변 입력 불가
            if (params.data.resentmenType === 'g3') {
              return false;
            }
            const numValue = Number(params.newValue?.toString().replace(/,/g, ''));
            if (!isNaN(numValue) && numValue >= 0) {
              params.data.creditAmount = numValue;
              // 대변 입력 시 차변 초기화
              if (numValue > 0) {
                params.data.debitAmount = 0;
              }
              return true;
            }
            return false;
          }
        },
        { headerName: "적요", field: "description", minWidth: 150, 
          editable: params => {
            // 소계 행은 편집 불가
            return !(params.data && params.data.isSummary === true);
          }
        }
      ],
      onGridReady: (params) => {
        detailGridApi = params.api;
        // 컬럼 너비 자동맞춤
        params.api.sizeColumnsToFit();
      },
      onSelectionChanged: (event) => {
        const selectedNodes = event.api.getSelectedNodes();
      },
      onRowClicked: (event) => {
        // 상세 그리드에서는 클릭해도 아무 작업 안함
      },
      onRowSelected: (event) => {
        // 행이 선택되었을 때만 다른 그리드의 선택을 해제합니다.
        if (event.node.isSelected() && purchaseSalesGridApi) {
          purchaseSalesGridApi.deselectAll();
        }
      },
      onCellFocused: (event) => {
        // 셀에 포커스가 맞춰질 때도 상세정보 표시 (단, 클릭이 아닌 키보드 이동 등의 경우만)
        if (event.rowIndex !== null && event.rowIndex >= 0) {
          const rowNode = detailGridApi.getDisplayedRowAtIndex(event.rowIndex);
          if (rowNode && rowNode.data) {
            // 이미 같은 마스터가 선택되어 있으면 중복 호출 방지
            if (selectedMaster && selectedMaster.entryNumber === rowNode.data.entryNumber) {
              return;
            }
            
            selectedMaster = rowNode.data;
            if (rowNode.data.entryNumber) {
              showDetailInfo(rowNode.data);
            } else {
              // 빈 행 포커스 시 상세정보 그리드 초기화
              if (purchaseSalesGridApi) {
                const current = [];
                purchaseSalesGridApi.forEachNode(node => current.push(node.data));
                purchaseSalesGridApi.applyTransaction({ remove: current });
              }
            }
          }
        }
      },
      onCellKeyDown: (event) => {
        const api = event.api;
        const currentRowIndex = event.node.rowIndex;
        const currentCol = event.colDef.field;
        const allColumns = detailGridOptions.columnDefs;
        const currentColIndex = allColumns.findIndex(col => col.field === currentCol);
        
        // --------------- ▼ F4 모달 추가 ▼ ------------------
        if (event.event.key === 'F4') {
          if (currentCol === 'accountCode') {
            // 계정과목 모달 열기 - 콜백으로 값 설정
            openAccountModal(currentRowIndex, (code, name) => {
              const node = api.getDisplayedRowAtIndex(currentRowIndex);
              if (node) {
                node.setDataValue('accountCode', String(code));
                node.setDataValue('accountName', String(name));
              }
            });
            event.event.preventDefault();
            return;
          } else if (currentCol === 'partnerCode') {
            // 거래처 모달 열기 - 콜백으로 값 설정
            openPartnerModal(currentRowIndex, (code, name) => {
              const node = api.getDisplayedRowAtIndex(currentRowIndex);
              if (node) {
                node.setDataValue('partnerCode', String(code));
                node.setDataValue('partnerName', String(name));
              }
            });
            event.event.preventDefault();
            return;
          }
        }
        // --------------- ▲ F4 모달 추가 ▲ ------------------
        
        // 기존 Enter 키 처리는 그대로 유지
        if (event.event.key === 'Enter') {
          event.event.preventDefault();
          event.event.stopPropagation();
          
          // API 유효성 검사
          if (!api || typeof api.getDisplayedRowCount !== 'function' || 
              typeof api.getDisplayedRowAtIndex !== 'function' ||
              typeof api.setFocusedCell !== 'function') {
            console.error('Enter 키 처리 시 API가 유효하지 않습니다.');
            return;
          }
          
          // 다음 editable 셀 찾기
          let nextColIndex = currentColIndex + 1;
          let nextRowIndex = currentRowIndex;
          
          while (true) {
            if (nextColIndex >= allColumns.length) {
              nextColIndex = 0;
              nextRowIndex++;
              if (nextRowIndex >= api.getDisplayedRowCount()) {
                // 마지막 행을 넘어가면 새 빈 행 추가
                if (selectedMaster && selectedMaster.entryNumber) {
                  const newEmptyRow = getEmptyDetailRow();
                  newEmptyRow.entryNumber = selectedMaster.entryNumber;
                  
                  // 소계 행이 있으면 그 위에 추가, 없으면 마지막에 추가
                  const summaryRowIndex = findSummaryRowIndex();
                  if (summaryRowIndex >= 0) {
                    api.applyTransaction({ 
                      add: [newEmptyRow], 
                      addIndex: summaryRowIndex 
                    });
                  } else {
                    api.applyTransaction({ add: [newEmptyRow] });
                  }
                  
                  setTimeout(() => {
                    // 새로 추가된 행에 포커스 (소계 행 위에 추가된 경우 해당 위치)
                    const focusRowIndex = summaryRowIndex >= 0 ? summaryRowIndex : api.getDisplayedRowCount() - 1;
                    api.setFocusedCell(focusRowIndex, allColumns[0].field);
                  }, 100);
                }
                return;
              }
            }
            
            const nextRowNode = api.getDisplayedRowAtIndex(nextRowIndex);
            if (!nextRowNode || !nextRowNode.data) {
              nextColIndex++;
              continue;
            }
            
            // 소계 행인 경우 건너뛰기
            if (nextRowNode.data.isSummary === true) {
              nextRowIndex++;
              nextColIndex = 0;
              if (nextRowIndex >= api.getDisplayedRowCount()) {
                // 마지막 행을 넘어가면 새 빈 행 추가
                if (selectedMaster && selectedMaster.entryNumber) {
                  const newEmptyRow = getEmptyDetailRow();
                  newEmptyRow.entryNumber = selectedMaster.entryNumber;
                  
                  // 소계 행이 있으면 그 위에 추가, 없으면 마지막에 추가
                  const summaryRowIndex = findSummaryRowIndex();
                  if (summaryRowIndex >= 0) {
                    api.applyTransaction({ 
                      add: [newEmptyRow], 
                      addIndex: summaryRowIndex 
                    });
                  } else {
                    api.applyTransaction({ add: [newEmptyRow] });
                  }
                  
                  setTimeout(() => {
                    // 새로 추가된 행에 포커스 (소계 행 위에 추가된 경우 해당 위치)
                    const focusRowIndex = summaryRowIndex >= 0 ? summaryRowIndex : api.getDisplayedRowCount() - 1;
                    api.setFocusedCell(focusRowIndex, allColumns[0].field);
                  }, 100);
                }
                return;
              }
              continue;
            }
            
            let editable = false;
            if (typeof allColumns[nextColIndex].editable === 'function') {
              editable = allColumns[nextColIndex].editable({ data: nextRowNode.data });
            } else {
              editable = allColumns[nextColIndex].editable;
            }
            
            if (editable) {
              setTimeout(() => {
                api.setFocusedCell(nextRowIndex, allColumns[nextColIndex].field);
              }, 50);
              break;
            }
            nextColIndex++;
          }
          return;
        }
      },
      onCellValueChanged: async (event) => {
        const rowData = event.data;
        
        // 구분 변경 시 금액 이동 처리
        if (event.colDef.field === 'resentmenType') {
          const newType = event.newValue;
          const oldType = event.oldValue;
          
          // 구분이 실제로 변경된 경우에만 처리
          if (newType !== oldType) {
            const currentDebit = rowData.debitAmount || 0;
            const currentCredit = rowData.creditAmount || 0;
            
            // 기존에 입력된 금액이 있는 경우
            if (currentDebit > 0 || currentCredit > 0) {
              // g3(차변)로 변경된 경우: 대변 금액을 차변으로 이동
              if (newType === 'g3' && currentCredit > 0) {
                event.node.setDataValue('debitAmount', currentCredit);
                event.node.setDataValue('creditAmount', 0);
              }
              // g4(대변)로 변경된 경우: 차변 금액을 대변으로 이동
              else if (newType === 'g4' && currentDebit > 0) {
                event.node.setDataValue('creditAmount', currentDebit);
                event.node.setDataValue('debitAmount', 0);
              }
              
              // 그리드 셀 새로고침
              setTimeout(() => {
                if (detailGridApi) {
                  detailGridApi.refreshCells({
                    rowNodes: [event.node],
                    columns: ['debitAmount', 'creditAmount'],
                    force: true
                  });
                }
              }, 50);
            }
          }
        }
        
        // 계정과목 코드 매핑 처리
        if (event.colDef.field === 'accountCode') {
          const accountCode = event.newValue;
          if (accountCode && !isNaN(accountCode)) {
            try {
              const response = await fetch(`/acc/act/${accountCode}`);
              if (response.ok) {
                const responseText = await response.text();
                if (responseText.trim()) {
                  try {
                    const account = JSON.parse(responseText);
                    if (account && account.accountName) {
                      event.node.setDataValue('accountName', account.accountName);
                      
                      // 그리드 셀 새로고침으로 화면 업데이트 확실히 하기
                      setTimeout(() => {
                        if (detailGridApi) {
                          detailGridApi.refreshCells({
                            rowNodes: [event.node],
                            columns: ['accountName'],
                            force: true
                          });
                        }
                      }, 50);
                    } else {
                      event.node.setDataValue('accountName', '');
                      alert("해당 계정과목을 찾을 수 없습니다.");
                    }
                  } catch (parseError) {
                    event.node.setDataValue('accountName', '');
                    alert("계정과목 정보 처리 중 오류가 발생했습니다.");
                  }
                } else {
                  event.node.setDataValue('accountName', '');
                  alert("계정과목 정보가 비어있습니다.");
                }
              } else {
                event.node.setDataValue('accountName', '');
                alert(`계정과목 조회 중 오류가 발생했습니다. (${response.status})`);
              }
            } catch (error) {
              event.node.setDataValue('accountName', '');
              alert("서버와 통신 중 오류가 발생했습니다.");
            }
          } else if (!accountCode) {
            event.node.setDataValue('accountName', '');
          }
        }
        
        // 거래처 코드 매핑 처리
        if (event.colDef.field === 'partnerCode') {
          const partnerCode = event.newValue;
          if (partnerCode && !isNaN(partnerCode)) {
            try {
              const response = await fetch(`/acc/pt/${partnerCode}`);
              if (response.ok) {
                const partner = await response.json();
                if (partner && partner.partnerName) {
                  event.node.setDataValue('partnerName', partner.partnerName);
                } else {
                  event.node.setDataValue('partnerName', '');
                  alert("해당 거래처를 찾을 수 없습니다.");
                }
              } else {
                event.node.setDataValue('partnerName', '');
                alert("거래처 조회 중 오류가 발생했습니다.");
              }
            } catch (error) {
              console.error('거래처 조회 오류:', error);
              event.node.setDataValue('partnerName', '');
              alert("서버와 통신 중 오류가 발생했습니다.");
            }
          } else if (!partnerCode) {
            event.node.setDataValue('partnerName', '');
          }
        }
        
        // 필수값이 모두 채워지면 자동 저장
        if (validateDetailRow(rowData)) {
          await saveDetailRow(rowData);
        }
        
        // 차변/대변 금액이 변경된 경우 소계 행 업데이트
        if (['debitAmount', 'creditAmount'].includes(event.colDef.field) && selectedMaster && selectedMaster.entryNumber) {
          setTimeout(() => {
            addDetailSummaryRow(selectedMaster.entryNumber);
          }, 100);
        }
      }
    };

    // 그리드 생성
    agGrid.createGrid(document.querySelector("#purchaseSalesGrid"), purchaseSalesGridOptions);
    agGrid.createGrid(document.querySelector("#detailGrid"), detailGridOptions);

    // 윈도우 크기 변경 시 그리드 컬럼 자동 맞춤
    window.addEventListener('resize', function() {
      setTimeout(() => {
        if (purchaseSalesGridApi) {
          purchaseSalesGridApi.sizeColumnsToFit();
        }
        if (detailGridApi) {
          detailGridApi.sizeColumnsToFit();
        }
      }, 100);
    });

    // 날짜 필터
    function filterByDate() {
      const startMonth = Number(document.querySelector('input[name="startMonth"]').value);
      const startDay = Number(document.querySelector('input[name="startDay"]').value);
      const endMonth = Number(document.querySelector('input[name="endMonth"]').value);
      const endDay = Number(document.querySelector('input[name="endDay"]').value);
      // 구분 필터 호출로 변경
      applyDateFilter();
    }

    // 이벤트 리스너
    ['startMonth', 'startDay', 'endMonth', 'endDay'].forEach(name => {
      document.querySelector(`input[name="${name}"]`).addEventListener('input', filterByDate);
    });

    // 상세 행 유효성 검사 함수 (필수값: 구분, 계정코드, 차변 또는 대변)
    function validateDetailRow(rowData) {
      return rowData.resentmenType && rowData.accountCode && 
             (rowData.debitAmount || rowData.creditAmount);
    }

    // 상세 행 저장 함수
    async function saveDetailRow(rowData) {
      if (!selectedMaster || !selectedMaster.entryNumber) {
        console.error('선택된 마스터가 없습니다.');
        return;
      }
      
      const isNew = !rowData.lineNumber;
      let method = isNew ? 'POST' : 'PUT';
      
      // 신규 저장 시 라인번호 할당
      if (isNew) {
        try {
          const response = await fetch(`/acc/enps/detail/lineNo/${selectedMaster.entryNumber}`);
          rowData.lineNumber = await response.json();
          rowData.entryNumber = selectedMaster.entryNumber;
        } catch (error) {
          console.error('라인번호 조회 실패:', error);
          alert("라인번호 조회 중 오류가 발생했습니다.");
          return;
        }
      }
      // 저장할 데이터 준비 (금액 처리)
      const saveData = {
        lineNumber: rowData.lineNumber,
        entryNumber: rowData.entryNumber,
        partnerCode: rowData.partnerCode || '',
        partnerName: rowData.partnerName || '',
        accountCode: rowData.accountCode || '',
        accountName: rowData.accountName || '',
        resentmenType: rowData.resentmenType || '',
        description: rowData.description || '',
        // amount 필드: 차변이면 양수, 대변이면 음수로 저장
        amount: rowData.debitAmount || rowData.creditAmount
      };
      try {
        const response = await fetch('/acc/enps/detail', {
          method: method,
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify([saveData])
        });
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const savedDetails = await response.json();
        
        if (savedDetails && savedDetails.length > 0) {
          const savedDetail = savedDetails[0];
          
          // 저장된 데이터로 그리드 업데이트
          Object.assign(rowData, savedDetail);
          
          // 그리드 새로 고침
          if (detailGridApi) {
            detailGridApi.refreshCells({ force: true });
            
            // 신규 저장 후 빈 행 확인 및 추가
            if (isNew) {
              setTimeout(() => {
                let hasEmptyRow = false;
                for (let i = 0; i < detailGridApi.getDisplayedRowCount(); i++) {
                  const row = detailGridApi.getDisplayedRowAtIndex(i)?.data;
                  if (row && isEmptyDetailRow(row)) {
                    hasEmptyRow = true;
                    break;
                  }
                }
                if (!hasEmptyRow) {
                  const newEmptyRow = getEmptyDetailRow();
                  newEmptyRow.entryNumber = selectedMaster.entryNumber;
                  
                  // 소계 행이 있으면 그 위에 추가, 없으면 마지막에 추가
                  const summaryRowIndex = findSummaryRowIndex();
                  if (summaryRowIndex >= 0) {
                    detailGridApi.applyTransaction({ 
                      add: [newEmptyRow], 
                      addIndex: summaryRowIndex 
                    });
                  } else {
                    detailGridApi.applyTransaction({ add: [newEmptyRow] });
                  }
                }
              }, 100);
            }
          }
        }
      } catch (error) {
        alert((isNew ? "신규 저장" : "수정") + " 실패: " + error.message);
      }
    }

    // 부가세 대상 거래 유형 (10% 부가세 적용)
    const taxableTransactionTypes = ['11', '14', '17', '21', '22', '51', '57', '61'];

    // 부가세 계산 함수
    function calculateTaxAmount(supplyAmount, transactionType) {
      if (taxableTransactionTypes.includes(transactionType)) {
        return Math.round(supplyAmount * 0.1);
      }
      return 0;
    }

    // 공급가액과 부가세로부터 합계 계산
    function calculateTotalAmount(supplyAmount, taxAmount) {
      return (supplyAmount || 0) + (taxAmount || 0);
    }

    // 합계에서 공급가액과 부가세 역산 계산
    function calculateFromTotal(totalAmount, transactionType) {
      if (!totalAmount) return { supplyAmount: 0, taxAmount: 0 };
      
      if (taxableTransactionTypes.includes(transactionType)) {
        // 부가세 있는 경우: 합계 = 공급가액 + (공급가액 * 0.1)
        // 합계 = 공급가액 * 1.1
        const supplyAmount = Math.round(totalAmount / 1.1);
        const taxAmount = totalAmount - supplyAmount;
        return { supplyAmount, taxAmount };
      } else {
        // 부가세 없는 경우: 합계 = 공급가액
        return { supplyAmount: totalAmount, taxAmount: 0 };
      }
    }

    // 행 데이터 자동 계산 함수
    function performAutoCalculation(rowData, changedField) {
      const quantity = Number(rowData.quantity) || 0;
      const unitPrice = Number(rowData.unitPrice) || 0;
      const totalAmount = Number(rowData.totalAmount) || 0;
      const supplyAmount = Number(rowData.totalSupplyAmount) || 0;
      const transactionType = rowData.transactionType || '';
      
      if (changedField === 'quantity' || changedField === 'unitPrice') {
        // 수량이나 단가가 변경된 경우
        if (quantity > 0 && unitPrice > 0) {
          const calculatedSupplyAmount = quantity * unitPrice;
          const taxAmount = calculateTaxAmount(calculatedSupplyAmount, transactionType);
          
          rowData.totalSupplyAmount = calculatedSupplyAmount;
          rowData.totalTaxAmount = taxAmount;
          rowData.totalAmount = calculateTotalAmount(calculatedSupplyAmount, taxAmount);
        }
      } else if (changedField === 'totalSupplyAmount') {
        // 공급가액이 직접 변경된 경우
        if (supplyAmount > 0) {
          const taxAmount = calculateTaxAmount(supplyAmount, transactionType);
          rowData.totalTaxAmount = taxAmount;
          rowData.totalAmount = calculateTotalAmount(supplyAmount, taxAmount);
        }
      } else if (changedField === 'totalAmount') {
        // 합계가 변경된 경우 (수량*단가가 입력되지 않았을 때만)
        if (!(quantity > 0 && unitPrice > 0) && totalAmount > 0) {
          const calculated = calculateFromTotal(totalAmount, transactionType);
          rowData.totalSupplyAmount = calculated.supplyAmount;
          rowData.totalTaxAmount = calculated.taxAmount;
        }
      } else if (changedField === 'transactionType') {
        // 거래유형이 변경된 경우
        const currentSupplyAmount = Number(rowData.totalSupplyAmount) || 0;
        if (currentSupplyAmount > 0) {
          const taxAmount = calculateTaxAmount(currentSupplyAmount, transactionType);
          rowData.totalTaxAmount = taxAmount;
          rowData.totalAmount = calculateTotalAmount(currentSupplyAmount, taxAmount);
        }
      }
    }

    // 요약 행 추가 함수
    function addSummaryRows(data) {
      if (!data.length) return [];
      const result = [];
      let grand = { totalSupplyAmount: 0, totalTaxAmount: 0, total: 0 };

      // 날짜 오름차순 정렬
      data = [...data].sort((a, b) => new Date(a.entryDate) - new Date(b.entryDate));

      // 그룹핑
      const groupBy = (arr, keyFn) => arr.reduce((acc, row) => {
        const key = keyFn(row);
        acc[key] = acc[key] || [];
        acc[key].push(row);
        return acc;
      }, {});

      // 월/분기/반기 그룹핑
      const getMonth = row => {
        const d = new Date(row.entryDate);
        return isNaN(d) ? (row.entryDate?.substr(5, 2) || '') : String(d.getMonth() + 1).padStart(2, '0');
      };
      const getQuarter = row => {
        const d = new Date(row.entryDate);
        const m = isNaN(d) ? parseInt(row.entryDate?.substr(5, 2)) : d.getMonth() + 1;
        return m ? `${Math.floor((m - 1) / 3) + 1}` : '';
      };
      const getHalf = row => {
        const d = new Date(row.entryDate);
        const m = isNaN(d) ? parseInt(row.entryDate?.substr(5, 2)) : d.getMonth() + 1;
        return m ? (m <= 6 ? '상' : '하') : '';
      };

      // 그룹핑된 키
      const byMonth = groupBy(data, getMonth);
      const byQuarter = groupBy(data, getQuarter);
      const byHalf = groupBy(data, getHalf);

      // 월/분기/반기/전체 합계 누적용
      let monthSum = {}, quarterSum = {}, halfSum = {};

      // 일자별 정렬
      const days = [...new Set(data.map(row => {
        const d = new Date(row.entryDate);
        if (isNaN(d)) return row.entryDate?.substr(5, 5) || '';
        const mm = String(d.getMonth() + 1).padStart(2, '0');
        const dd = String(d.getDate()).padStart(2, '0');
        return `${mm}-${dd}`;
      }))].sort();

      // 월/분기/반기/전체 마지막 일자인지 체크 함수
      const isLastOfGroup = (idx, arr, groupFn) => {
        if (idx === arr.length - 1) return true;
        return groupFn(arr[idx]) !== groupFn(arr[idx + 1]);
      };

      // 일자별로 루프
      for (let i = 0; i < data.length;) {
        const curRow = data[i];
        const curDate = curRow.entryDate;
        const d = new Date(curDate);
        const mm = isNaN(d) ? (curDate?.substr(5, 2) || '') : String(d.getMonth() + 1).padStart(2, '0');
        const dd = isNaN(d) ? (curDate?.substr(8, 2) || '') : String(d.getDate()).padStart(2, '0');
        const dayKey = `${mm}-${dd}`;

        // 같은 일자 데이터 모으기
        const dayRows = [];
        while (
          i < data.length &&
          (() => {
            const row = data[i];
            const d2 = new Date(row.entryDate);
            const mm2 = isNaN(d2) ? (row.entryDate?.substr(5, 2) || '') : String(d2.getMonth() + 1).padStart(2, '0');
            const dd2 = isNaN(d2) ? (row.entryDate?.substr(8, 2) || '') : String(d2.getDate()).padStart(2, '0');
            return `${mm2}-${dd2}` === dayKey;
          })()
        ) {
          dayRows.push(data[i]);
          i++;
        }

        // 일자 데이터 push
        dayRows.forEach(row => {
          result.push(row);

          // 누적
          grand.totalSupplyAmount += row.totalSupplyAmount || 0;
          grand.totalTaxAmount += row.totalTaxAmount || 0;
          grand.total += (row.totalSupplyAmount || 0) + (row.totalTaxAmount || 0);

          // 월/분기/반기 누적
          const month = getMonth(row);
          const quarter = getQuarter(row);
          const half = getHalf(row);

          monthSum[month] = monthSum[month] || { totalSupplyAmount: 0, totalTaxAmount: 0, total: 0, count: 0 };
          monthSum[month].totalSupplyAmount += row.totalSupplyAmount || 0;
          monthSum[month].totalTaxAmount += row.totalTaxAmount || 0;
          monthSum[month].total += (row.totalSupplyAmount || 0) + (row.totalTaxAmount || 0);
          monthSum[month].count++;

          quarterSum[quarter] = quarterSum[quarter] || { totalSupplyAmount: 0, totalTaxAmount: 0, total: 0, count: 0 };
          quarterSum[quarter].totalSupplyAmount += row.totalSupplyAmount || 0;
          quarterSum[quarter].totalTaxAmount += row.totalTaxAmount || 0;
          quarterSum[quarter].total += (row.totalSupplyAmount || 0) + (row.totalTaxAmount || 0);
          quarterSum[quarter].count++;

          halfSum[half] = halfSum[half] || { totalSupplyAmount: 0, totalTaxAmount: 0, total: 0, count: 0 };
          halfSum[half].totalSupplyAmount += row.totalSupplyAmount || 0;
          halfSum[half].totalTaxAmount += row.totalTaxAmount || 0;
          halfSum[half].total += (row.totalSupplyAmount || 0) + (row.totalTaxAmount || 0);
          halfSum[half].count++;
        });

        // 일계
        result.push({
          entryDate: `${dayKey} 일계 [ ${dayRows.length} 건 ]`,
          totalSupplyAmount: dayRows.reduce((a, b) => a + (b.totalSupplyAmount || 0), 0),
          totalTaxAmount: dayRows.reduce((a, b) => a + (b.totalTaxAmount || 0), 0),
          total: dayRows.reduce((a, b) => a + (b.totalSupplyAmount || 0) + (b.totalTaxAmount || 0), 0),
          isSubtotal: true
        });

        // 월계
        if (
          i === data.length ||
          getMonth(data[i - 1]) !== getMonth(data[i])
        ) {
          const month = getMonth(dayRows[0]);
          const ms = monthSum[month];
          result.push({
            entryDate: `${month}월계 [ ${ms.count} 건 ]`,
            totalSupplyAmount: ms.totalSupplyAmount,
            totalTaxAmount: ms.totalTaxAmount,
            total: ms.total,
            isSubtotal: true
          });
          // 월 누적 초기화
          monthSum[month] = undefined;
        }

        // 분기계
        if (
          i === data.length ||
          getQuarter(data[i - 1]) !== getQuarter(data[i])
        ) {
          const quarter = getQuarter(dayRows[0]);
          const qs = quarterSum[quarter];
          result.push({
            entryDate: `${quarter}분기계 [ ${qs.count} 건 ]`,
            totalSupplyAmount: qs.totalSupplyAmount,
            totalTaxAmount: qs.totalTaxAmount,
            total: qs.total,
            isSubtotal: true
          });
          quarterSum[quarter] = undefined;
        }

        // 반기계
        if (
          i === data.length ||
          getHalf(data[i - 1]) !== getHalf(data[i])
        ) {
          const half = getHalf(dayRows[0]);
          const hs = halfSum[half];
          result.push({
            entryDate: `${half}반기계 [ ${hs.count} 건 ]`,
            totalSupplyAmount: hs.totalSupplyAmount,
            totalTaxAmount: hs.totalTaxAmount,
            total: hs.total,
            isSubtotal: true
          });
          halfSum[half] = undefined;
        }
      }

      // 소계
      result.push({
        entryDate: '소계',
        totalSupplyAmount: grand.totalSupplyAmount,
        totalTaxAmount: grand.totalTaxAmount,
        total: grand.total,
        isGrandTotal: true
      });

      return result;
    }
  </script>
</div>