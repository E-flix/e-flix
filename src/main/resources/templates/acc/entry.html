<html xmlns:th="http://www.thymeleaf.org" xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout" layout:decorate="~{common/layouts/default}">
<!-- ============================================
  - ì‘ì„±ì   : ê¹€í¬ì •
  - ìµœì´ˆì‘ì„± : 2025-06-18
  - ì„¤ëª…     : ì¼ë°˜ì „í‘œ í™”ë©´
  -----------------------------------------------
  [ ë³€ê²½ ì´ë ¥ ]
  - 2025-06-18 (ê¹€í¬ì •): title ë° ë‚´ìš© ì¶”ê°€
  - 2025-06-20 (ê¹€í¬ì •): ë ˆì´ì•„ì›ƒ ë° ag-grid ì„¸íŒ…(enter ì´ë™/ ì‚­ì œ(view))
  - 2025-06-23 (ê¹€í¬ì •): DB ì—°ê²° (select)
                       : êµ¬ë¶„ field ë²ˆí˜¸ë¡œ ì…ë ¥í•˜ë©´ ìë™ìœ¼ë¡œ ë§¤ì¹­ 1:ì¶œê¸ˆ 2:ì…ê¸ˆ 3:ì°¨ë³€ 4:ëŒ€ë³€
                       : ìˆ«ì ì²œë‹¨ìœ„ ë°ì´í„° í¬ë§·
                       : editableê°€ flaseì¸ ì…€ì€ í¬ì»¤ìŠ¤ ì œì™¸
                       : í•„ìˆ˜ ê°’ ì…ë ¥ ì•ˆí•˜ë©´ í–‰ ì €ì¥ ë¶ˆê°€ (ë‚ ì§œ,ì°¨ëŒ€ë³€,ê³„ì •ê³¼ëª©ì½”ë“œ,ê¸ˆì•¡)
                       : ê°€ì¥ ì•„ë˜ ì…ë ¥í• ìˆ˜ ìˆëŠ” ì¹¸ ì¶”ê°€
                       : ì½”ë“œ(ê±°ë˜ì²˜/ê³„ì •ê³¼ëª©) ì…ë ¥í•˜ë©´ ì´ë¦„(ê±°ë˜ì²˜/ê³„ì •ê³¼ëª©) ë¶ˆëŸ¬ì˜¤ê¸° 
                       : resentmenType ë³€ê²½ ê°ì§€í•´ì„œ ê°’ ìœ„ì¹˜ ë³€ê²½
                       : ì½”ë“œ fieldì—ì„œ F4ë¥¼ ëˆ„ë¥´ë©´ ëª¨ë‹¬ì°½(ê³„ì •ê³¼ëª© / ê±°ë˜ì²˜) ë„ì›Œì£¼ê³  ë°ì´í„°ë°›ì•„ì„œ í•´ë‹¹ ì…€ì˜ valueê°’ ë³€ê²½
  - 2025-06-24 (ê¹€í¬ì •): DB ì—°ê²° (delete)  
                       : í–‰ ì¶”ê°€ì‹œ ì‹ ê·œ ì „í‘œë²ˆí˜¸ ì¡°íšŒ          
  - 2025-06-26 (ê¹€í¬ì •): ë‚ ì§œ ê²€ìƒ‰ í•„í„°
  - 2025-06-26 (ê¹€í¬ì •): DB ì—°ê²° (insert)
  - 2025-06-26 (ê¹€í¬ì •): ê°™ì€ ì „í‘œë²ˆí˜¸ ë‚´ì—ì„œ ì°¨ëŒ€ë³€ ì°¨ì•¡ ë°œìƒí•˜ë©´ ì°¨ì•¡ í‘œì‹œí•˜ëŠ” ê¸°ëŠ¥ êµ¬í˜„ (ì „í‘œ ì†Œê³„ ì—´/ í•©ê³„ ì—´)
  - 2025-06-26 (ê¹€í¬ì •): ì „í‘œë²ˆí˜¸ ìë™ë¶€ì—¬ = select max+1 or ì „í‘œë‚´ ì°¨ì•¡ìˆìœ¼ë©´ ì°¨ì•¡ ìˆëŠ” ì „í‘œë²ˆí˜¸
  -----------------------------------------------
  [ TODO ] 
  1. í´ë¦­í•œ ì¤„ê³¼ ê°™ì€ number fieldì˜ ê°’ì„ ê°€ì§€ê³  ìˆë‹¤ë©´ ë°°ê²½ìƒ‰ ê°•ì¡° í‘œì‹œ (2ë²ˆê³¼ ì—°ê²°)
  2. ë‹¤ í•˜ë©´ ìì£¼ ì‚¬ìš©ë˜ëŠ” ag-grid ì„¸íŒ…ì€ ë³„ë„ì˜ classë§Œë“¤ê³  importí•´ì„œ ì‚¬ìš©í•˜ê¸°
============================================ -->

<head>
  <title>ì¼ë°˜ì „í‘œ</title>
  <style>
    .ag-theme-alpine .ag-row-even, 
    .ag-theme-alpine .ag-row-odd {
      background: white !important;
    }
    .ag-row-total .ag-cell {
      background-color: #fff3cd !important;
      color: #856404 !important;
      font-weight: bold !important;
    }
    .subtotal-row .ag-cell {
      background: #f3f6fa !important;
      font-weight: bold !important;
      text-align: center;
    }
    /* ê°™ì€ ì „í‘œë²ˆí˜¸ ê°•ì¡° í‘œì‹œ */
    .ag-row-highlighted .ag-cell {
      background-color: #e3f2fd !important;
    }
    .ag-row-highlighted .ag-cell:first-child {
      border-left: 3px solid #2196f3 !important;
    }
    .ag-row-highlighted.ag-row-selected .ag-cell {
      background-color: #bbdefb !important;
    }
  </style>
</head>
<div layout:fragment="content">
  <!-- ëª¨ë‹¬ ë¶ˆëŸ¬ì˜¤ê¸° -->
  <div th:replace="acc/modal/modal :: modals"></div>
  <div class="w-100" id="account">
    <div class="d-flex justify-content-between align-items-center mb-1">
      <!-- ì™¼ìª½: ì¼ë°˜ì „í‘œ ì œëª© -->
      <h3 class="mb-0">ì¼ë°˜ì „í‘œ</h3>
      <!-- ì˜¤ë¥¸ìª½: ë²„íŠ¼ ëª¨ìŒ -->
      <div>
        <button class="btn btn-outline-secondary btn-sm" onclick="location.href='/voucher/excel-template'">ì—‘ì…€ ì„œì‹ ë‚´ë ¤ë°›ê¸°</button>
        <button class="btn btn-outline-secondary btn-sm" data-bs-toggle="modal" data-bs-target="#excelUploadModal">ì—‘ì…€ ì—…ë¡œë“œí•˜ê¸°</button>
        <button class="btn btn-outline-secondary btn-sm" onclick="deleteSelectedRow()">ì‚­ì œ</button>
        <button class="btn btn-outline-secondary btn-sm" onclick="window.print()">ì¸ì‡„</button>
      </div>
    </div>
    <!-- ì—‘ì…€ ì—…ë¡œë“œ ëª¨ë‹¬ -->
    <div class="modal fade" id="excelUploadModal" tabindex="-1">
      <div class="modal-dialog">
        <form class="modal-content" enctype="multipart/form-data" method="post" action="/voucher/upload">
          <div class="modal-header">
            <h5 class="modal-title">ì—‘ì…€ ì—…ë¡œë“œ</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
          </div>
          <div class="modal-body">
            <input type="file" name="excelFile" accept=".xlsx,.xls" class="form-control">
          </div>
          <div class="modal-footer">
            <button type="submit" class="btn btn-success">ì—…ë¡œë“œ</button>
          </div>
        </form>
      </div>
    </div>
    <!-- ê²€ìƒ‰/í•„í„° ì˜ì—­ -->
    <form class="row g-2 mb-2 align-items-end" method="get" action="/voucher/list">
      <div class="col-auto">
        <label class="form-label mb-0">ì¼ì</label>
        2025 ë…„
        <input type="number" value="1" class="form-control form-control-sm d-inline-block" name="startMonth" style="width:45px;"> ì›”
        <input type="number" value="1" class="form-control form-control-sm d-inline-block" name="startDay" style="width:45px;"> ì¼ ~
        2025 ë…„
        <input type="number" value="12" class="form-control form-control-sm d-inline-block" name="endMonth" style="width:45px;"> ì›”
        <input type="number" value="31" class="form-control form-control-sm d-inline-block" name="endDay" style="width:45px;"> ì¼
      </div>
    </form>
    <!-- ë³¸ë¬¸ ag-Grid -->
    <div class="grid-container" style="height:75vh;">
      <div id="entryGrid" class="ag-theme-alpine" style="width:100%; height:100%;"></div>
    </div>
  </div>
  
  <script th:inline="javascript">
    let gridApi = null;
    let lastSummaryEntryNumber = null;
    let debounceTimer = null;
    let enterPressedForMove = false;
    let firstDiffEntryNumber = null;
    let highlightedEntryNumber = null; // ê°•ì¡° í‘œì‹œí•  ì „í‘œë²ˆí˜¸
    let arrowKeyDebounceTimer = null; // ë°©í–¥í‚¤ ë””ë°”ìš´ìŠ¤ íƒ€ì´ë¨¸
    // select max(entryNumber)+1 (ì‹ ê·œ ì „í‘œë²ˆí˜¸)
    let enNo = 1; // í–‰ ì¶”ê°€ì‹œ ì´ˆê¸°í™”
    selectEnNo();
    // ì‹ ê·œ ì „í‘œë²ˆí˜¸ select í•¨ìˆ˜
    async function selectEnNo() {
      try {
        const response = await fetch('/acc/en/enNo');
        enNo = await response.json();
      } catch (err) {
        console.error('ì „í‘œë²ˆí˜¸ ì¡°íšŒ ì‹¤íŒ¨:', err);
        return null;
      }
    }
    // ì‹ ê·œ ë¼ì¸ë²ˆí˜¸ select í•¨ìˆ˜
    async function selectLineNo(entryNumber) {
      entryNumber = entryNumber ?? 0;
      try {
        const response = await fetch(`/acc/en/${entryNumber}`);
        let lineNo = await response.json();
        return lineNo;
      } catch (err) {
        console.error('ì „í‘œë²ˆí˜¸ ì¡°íšŒ ì‹¤íŒ¨:', err);
        return null;
      }
    }
    // ë…„ë„
    let entryYear = 2025;
    // ë¡œê·¸ì¸ìœ ì €
    let loginUser = 'loginUser';
    // ì „ì²´ì¡°íšŒ API
    let entryList = /*[[${entryList}]]*/[]; // DB ì¡°íšŒ
    let rowData = []; // ì‹¤ì œ Listë§Œë“¤ ë°°ì—´
    entryList.forEach(master => {
      if (master.entryType !== 'ì¼ë°˜') return; // entryTypeì´ ì¼ë°˜ì´ ì•„ë‹Œ ê²ƒì€ ê±´ë„ˆëœ€
      master.details.forEach(detail => {
        // ë‚ ì§œ ì•ˆì „í•˜ê²Œ íŒŒì‹±
        const entryDate = new Date(master.entryDate);
        const isValidDate = !isNaN(entryDate.getTime());
        
        rowData.push({
          year: isValidDate ? entryDate.getFullYear() : new Date().getFullYear(),               // ë…„
          month: isValidDate ? entryDate.getMonth() + 1 : new Date().getMonth() + 1,             // ì›”
          day: isValidDate ? entryDate.getDate() : new Date().getDate(),                    // ì¼
          entryNumber: master.entryNumber,                              // ì „í‘œë²ˆí˜¸
          resentmenType: detail.resentmenType,                          // êµ¬ë¶„
          accountCode: detail.accountCode,                              // ê³„ì •ì½”ë“œ
          accountName: detail.accountName,                              // ê³„ì •ê³¼ëª©ëª…
          partnerCode: detail.partnerCode,                              // ì½”ë“œ 
          partnerName: detail.partnerName,                              // ê±°ë˜ì²˜ëª…
          debit: detail.resentmenType === 'g3' ? detail.amount : null,  // ì°¨ë³€
          credit: detail.resentmenType === 'g4' ? detail.amount : null, // ëŒ€ë³€
          description: detail.description,                              // ì ìš”
          lineNumber: detail.lineNumber ?? null                         // ë¼ì¸ë²ˆí˜¸
        });
      });
    });
    // rowData ì´ˆê¸°ê°’ ë§Œë“¤ ë•Œ ë§¨ ëì— ë¹ˆ í–‰ ì¶”ê°€
    const initialEmptyRow = {
      month: null,
      day: null,
      entryNumber: null,
      resentmenType: '',
      accountCode: '',
      accountName: '',
      partnerCode: '',
      partnerName: '',
      debit: null,
      credit: null,
      description: '',
      lineNumber: null
    };
    // ìœ ë‹ˆí¬í•œ ID ë¯¸ë¦¬ í• ë‹¹
    initialEmptyRow._emptyRowId = `empty_row_${Date.now()}_${Math.random()}`;
    rowData.push(initialEmptyRow);
    updateFirstDiffEntryNumber();
    // --------------- â–¼ í•„ìˆ˜ ê°’ ê²€ì¦ (ì…ë ¥ ë° ìˆ˜ì •ì‹œ ì‚¬ìš©) â–¼ ------------------ 
    const requiredFields = new Set(['month', 'day', 'resentmenType', 'accountCode']);
    function isRowValid(rowData, currentField) {
      if (currentField && !requiredFields.has(currentField)) return true;

      // í˜„ì¬ í•„ë“œë³„ ë‹¨ê³„ì  ê²€ì¦
      switch (currentField) {
        case 'month':
          return validateMonth(rowData);
        case 'day':
          return validateMonth(rowData) && validateDay(rowData);
        case 'resentmenType':
          return validateMonth(rowData) && validateDay(rowData) && !!rowData.resentmenType;
        case 'accountCode':
          return validateMonth(rowData) && validateDay(rowData) && !!rowData.resentmenType && !!rowData.accountCode;
      }

      // ì „ì²´ í–‰ ê²€ì¦ (ì €ì¥ ì‹œ)
      return validateFullRow(rowData);
    }
    // ì›” ê²€ì¦ (1~12)
    function validateMonth(rowData) {
      const month = Number(rowData.month);
      return !isNaN(month) && month >= 1 && month <= 12;
    }
    // ì¼ ê²€ì¦ (1~31)
    function validateDay(rowData) {
      const day = Number(rowData.day);
      return !isNaN(day) && day >= 1 && day <= 31;
    }
    // ì „ì²´ í–‰ ê²€ì¦
    function validateFullRow(rowData) {
      if (!validateMonth(rowData) || !validateDay(rowData)) {
        return false;
      }
      
      if (!rowData.resentmenType || !rowData.accountCode) {
        return false;
      }

      const debit = Number(rowData.debit) || 0;
      const credit = Number(rowData.credit) || 0;

      if (rowData.resentmenType === 'g3') {
        const result = debit >= 1;
        return result;
      }
      if (rowData.resentmenType === 'g4') {
        const result = credit >= 1;
        return result;
      }
      
      const result = debit >= 1 || credit >= 1;
      return result;
    }
    // --------------- â–² í•„ìˆ˜ ê°’ ê²€ì¦ (ì…ë ¥ ë° ìˆ˜ì •ì‹œ ì‚¬ìš©) â–² ------------------ 

    // ag-Grid ì„¸íŒ…
    const gridOptions = {
      suppressClickEdit: true,
      singleClickEdit: false,
      getRowId: params => {
        const data = params.data;
        // Summary row
        if (data.isSummary) {
          if (data.isSummaryType === 'subtotal') {
            const entryNum = data._summaryEntryNumber || 'unknown';
            return `summary_subtotal_${entryNum}`;
          } else if (data.isSummaryType === 'total') {
            return `summary_total_global`;
          }
          return `summary_default_${Date.now()}`;
        }

        // ì¼ë°˜ ë°ì´í„° í–‰ (entryNumberì™€ lineNumberë¡œ ê³ ìœ  ID ìƒì„±)
        if (data.entryNumber != null && data.lineNumber != null) {
          return `entry_${data.entryNumber}_line_${data.lineNumber}`;
        }

        // ë¹ˆ í–‰ (ì‹ ê·œ í–‰) ì²˜ë¦¬
        if (!data.entryNumber && !data.lineNumber) {
          // _emptyRowIdê°€ ì—†ìœ¼ë©´ ìƒˆë¡œ ìƒì„±í•˜ì—¬ í• ë‹¹
          if (!data._emptyRowId) {
            data._emptyRowId = `empty_row_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
          }
          return data._emptyRowId;
        }

        // ì˜ˆì™¸ ì¼€ì´ìŠ¤: ê³ ìœ  IDë¥¼ ìƒì„±í•  ìˆ˜ ì—†ëŠ” ê²½ìš°
        return undefined;
      },
      getRowClass: params => {
        let classes = [];
        
        if (params.data?.isSummary) {
          if (params.data.isSummaryType === 'subtotal') {
            classes.push('subtotal-row');
          } else if (params.data.isSummaryType === 'total') {
            classes.push('ag-row-total');
          } else {
            classes.push('ag-row-summary');
          }
        }
        
        // ê°™ì€ ì „í‘œë²ˆí˜¸ ê°•ì¡° í‘œì‹œ
        if (highlightedEntryNumber && 
            params.data?.entryNumber === highlightedEntryNumber &&
            !params.data?.isSummary) {
          classes.push('ag-row-highlighted');
        }
        
        return classes.length > 0 ? classes.join(' ') : null;
      },
      getRowStyle: params => {
        if (params.data?.isSummary && params.data.isSummaryType !== 'subtotal') {
          return { background: '#f5f5f5', fontWeight: 'bold', color: '#d32f2f' };
        }
        return null;
      },
      // í—¤ë” ë†’ì´ ì§€ì •
      headerHeight: 35,
      // í–‰ ë†’ì´ ì§€ì •
      rowHeight: 35,
      // ê·¸ë¦¬ë“œ values ë°°ì—´
      rowData: rowData,
      // ê·¸ë¦¬ë“œ í•„ë“œëª… ì •ì˜
      columnDefs: [
        { 
          headerName: "ì›”", 
          field: "month", 
          editable: params => !params.data?.isSummary, 
          minWidth: 55, 
          maxWidth: 55, 
          cellClass: 'ag-center-aligned-cell', 
          colSpan: params => {
            if (params.data?.isSummary) {
              // summary rowì˜ ê²½ìš° ì›”~ê³„ì •ê³¼ëª©ëª…ê¹Œì§€ 6ì¹¸ ë³‘í•©
              return 6;
            }
            return 1;
          },
          cellRenderer: params => {
            if (params.data?.isSummary) {
              if (params.data.isSummaryType === 'subtotal') {
                return params.data.month;
              } else if (params.data.isSummaryType === 'total') {
                return '<div style="text-align:center; font-weight:bold; color:#856404; padding:5px;">ğŸ“ˆ ì „ì²´ í•©ê³„</div>';
              }
            }
            return params.value;
          }
        },
        { headerName: "ì¼", field: "day", editable: params => !params.data?.isSummary, minWidth: 55, maxWidth: 55, cellClass: 'ag-center-aligned-cell' },
        { headerName: "ë²ˆí˜¸", field: "entryNumber", editable: () => false, minWidth: 75, maxWidth: 75, cellClass: 'ag-center-aligned-cell' },
        { headerName: "êµ¬ë¶„", field: "resentmenType", editable: params => !params.data?.isSummary, minWidth: 70, maxWidth: 70, cellClass: 'ag-center-aligned-cell',
          valueFormatter: params => {
            // g1~g4 -> í•œê¸€ í‘œì‹œ
            const map = { g1: 'ì¶œê¸ˆ', g2: 'ì…ê¸ˆ', g3: 'ì°¨ë³€', g4: 'ëŒ€ë³€' };
            return map[params.value] || params.value;
          },
          valueParser: params => {
            // ì‚¬ìš©ì ì…ë ¥ê°’ ìˆ«ì -> g ì½”ë“œë¡œ ë³€í™˜
            const map = { '1': 'g1', '2': 'g2', '3': 'g3', '4': 'g4' };
            const trim = params.newValue?.toString().trim();
            return map[trim] || params.newValue; // ë³€í™˜ ë¶ˆê°€ ì‹œ ì›ë˜ê°’ ë°˜í™˜
          },
          valueSetter: params => {
            const map = { '1': 'g1', '2': 'g2', '3': 'g3', '4': 'g4' };
            let newVal = params.newValue;
            if (map[newVal]) newVal = map[newVal];
            if (params.newValue && params.newValue.startsWith('g')) {
              params.data.resentmenType = params.newValue;
              return true; // í—ˆìš©
            }
            return false; // ë³€ê²½ ê±°ë¶€ (ê¸°ì¡´ ê°’ ìœ ì§€)
          }
        },
        { headerName: "ì½”ë“œ", field: "accountCode", editable: params => !params.data?.isSummary, minWidth: 70, maxWidth: 70, cellClass: 'ag-center-aligned-cell' },
        { headerName: "ê³„ì •ê³¼ëª©", field: "accountName", editable: () => false, minWidth: 100, maxWidth: 100, cellClass: 'ag-left-aligned-cell' },
        { headerName: "ì½”ë“œ", field: "partnerCode", editable: params => !params.data?.isSummary, minWidth: 80, maxWidth: 80, cellClass: 'ag-center-aligned-cell' },
        { headerName: "ê±°ë˜ì²˜", field: "partnerName", editable: params => !params.data?.isSummary, initialWidth: 250, cellClass: 'ag-left-aligned-cell' },
        {
          headerName: "ì°¨ë³€", field: "debit", editable: params => params.data.resentmenType !== 'g4' && !params.data?.isSummary, initialWidth: 135, minWidth: 100, valueFormatter: p => p.value?.toLocaleString(), cellClass: 'ag-right-aligned-cell',
          valueSetter: params => {
            const val = Number(params.newValue);
            if (!isNaN(val) && val >= 1) {
              params.data.debit = val;
              return true;
            } else {
              alert("ì°¨ë³€ì€ 0 ì´ìƒì˜ ìˆ«ìë§Œ ì…ë ¥ ê°€ëŠ¥í•©ë‹ˆë‹¤.");
              return false; // ì…ë ¥ ê±°ë¶€
            }
          }
        },
        {
          headerName: "ëŒ€ë³€", field: "credit", editable: params => params.data.resentmenType !== 'g3' && !params.data?.isSummary, initialWidth: 135, minWidth: 100, valueFormatter: p => p.value?.toLocaleString(), cellClass: 'ag-right-aligned-cell',
          valueSetter: params => {
            const val = Number(params.newValue);
            if (!isNaN(val) && val >= 1) {
              params.data.credit = val;
              return true;
            } else {
              alert("ëŒ€ë³€ì€ 0 ì´ìƒì˜ ìˆ«ìë§Œ ì…ë ¥ ê°€ëŠ¥í•©ë‹ˆë‹¤.");
              return false; // ì…ë ¥ ê±°ë¶€
            }
          }
        },
        { headerName: "ì ìš”", field: "description", editable: params => !params.data?.isSummary, minWidth: 400 },
      ],
      onRowClicked: (event) => {
        if (event.data?.isSummary) {
          event.api.deselectAll();
          return;
        }
      },
      onCellClicked: (event) => {
        if (event.data?.isSummary) {
          event.api.deselectAll();
          event.api.clearFocusedCell(); // summary row í´ë¦­ ì‹œ í¬ì»¤ìŠ¤ë„ í•´ì œ
          return;
        }
        
        // í´ë¦­í•œ ì…€ì— í¬ì»¤ìŠ¤ ì„¤ì •
        const rowIndex = event.rowIndex;
        const colId = event.column.getColId();
        event.api.setFocusedCell(rowIndex, colId);
      },
      isRowSelectable: rowNode => !rowNode.data?.isSummary,
      // í–‰ ì„ íƒ ë°©ì‹ì„ ì§€ì •
      rowSelection: {
        mode: 'multiRow', // 'single'==> ë‹¨ì¼ ì„ íƒ, 'multiRow' ==> ë‹¤ì¤‘ ì„ íƒ
        enableClickSelection: false, // í´ë¦­ìœ¼ë¡œ í–‰ ì„ íƒ ë¹„í™œì„±í™”
        isRowSelectable: rowNode => !rowNode.data?.isSummary
      },
      onGridReady: (params) => {
        gridOptions.api = params.api;
        gridOptions.columnApi = params.columnApi;
        
        // ê·¸ë¦¬ë“œ ì¤€ë¹„ ì™„ë£Œ í›„ ë¹ˆ í–‰ì´ ìˆìœ¼ë©´ ì²« ë²ˆì§¸ ì…€ì— í¬ì»¤ìŠ¤
        setTimeout(() => {
          // API ìœ íš¨ì„± í™•ì¸
          if (!params.api || typeof params.api.getDisplayedRowCount !== 'function') {
            console.warn('onGridReady: APIê°€ ì•„ì§ ì™„ì „íˆ ì¤€ë¹„ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
            return;
          }
          
          let hasEmptyRow = false;
          
          for (let i = 0; i < params.api.getDisplayedRowCount(); i++) {
            const row = params.api.getDisplayedRowAtIndex(i)?.data;
            if (row && isEmptyRow(row)) {
              params.api.setFocusedCell(i, gridOptions.columnDefs[0].field);
              hasEmptyRow = true;
              break;
            }
          }
          
          // ë¹ˆ í–‰ì´ ì—†ìœ¼ë©´ í•˜ë‚˜ ì¶”ê°€
          if (!hasEmptyRow) {
            const newEmptyRow = getEmptyRow();
            params.api.applyTransaction({ add: [newEmptyRow] });
            
            setTimeout(() => {
              const lastRowIndex = params.api.getDisplayedRowCount() - 1;
              params.api.setFocusedCell(lastRowIndex, gridOptions.columnDefs[0].field);
            }, 50);
          }
        }, 100);
      },
      onCellFocused: async (event) => {
        const api = gridOptions.api;
        if (!api || event.rowIndex == null) return;

        const focusedNode = api.getDisplayedRowAtIndex(event.rowIndex);
        if (!focusedNode || !focusedNode.data) return;

        const focusedRowData = focusedNode.data;

        if (focusedRowData.isSummary) {
          return;
        }

        // ê°™ì€ ì „í‘œë²ˆí˜¸ ê°•ì¡° í‘œì‹œ ì—…ë°ì´íŠ¸
        const focusedEntryNumber = focusedRowData.entryNumber;
        if (focusedEntryNumber && focusedEntryNumber !== highlightedEntryNumber) {
          highlightedEntryNumber = focusedEntryNumber;
          // ëª¨ë“  í–‰ì˜ í´ë˜ìŠ¤ë¥¼ ë‹¤ì‹œ ê³„ì‚°í•˜ì—¬ ê°•ì¡° í‘œì‹œ ì—…ë°ì´íŠ¸
          api.redrawRows();
        } else if (!focusedEntryNumber && highlightedEntryNumber) {
          // ë¹ˆ í–‰ì— í¬ì»¤ìŠ¤ëœ ê²½ìš° ê°•ì¡° í‘œì‹œ í•´ì œ
          highlightedEntryNumber = null;
          api.redrawRows();
        }

        const currentEntryNumber = focusedRowData.entryNumber;

        if (!currentEntryNumber) {
          if (lastSummaryEntryNumber !== null) {
            await removeSummaryRows(api);
            lastSummaryEntryNumber = null;
          }
          return;
        }

        if (currentEntryNumber === lastSummaryEntryNumber) {
          return;
        }

        setTimeout(async () => {
          try {
            await removeSummaryRows(api);
            await generateAndAddSummaryRow(currentEntryNumber);
            lastSummaryEntryNumber = currentEntryNumber;
          } catch (error) {
            console.error('Summary row ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:', error);
            lastSummaryEntryNumber = null;
          }
        }, 0);
      },
      // Enter í‚¤ ì…ë ¥ ì‹œ ë‹¤ìŒ ì…€ë¡œ í¬ì»¤ìŠ¤ë¥¼ ì´ë™í•˜ëŠ” ë¡œì§
      onCellKeyDown: async (event) => {
        const api = event.api;
        // í˜„ì¬ í¬ì»¤ìŠ¤ëœ í–‰ì˜ ì¸ë±ìŠ¤ ë°˜í™˜ (ì „ì²´ í–‰ë“¤ ì¤‘ ì¸ë±ìŠ¤)
        const currentRowIndex = event.node.rowIndex;
        // í˜„ì¬ í¬ì»¤ìŠ¤ëœ ì»¬ëŸ¼ì˜ í•„ë“œëª… ë°˜í™˜
        const currentCol = event.colDef.field;
        // ì „ì²´ columnDefsë¡œë¶€í„° í˜„ì¬ ì»¬ëŸ¼ì˜ ì¸ë±ìŠ¤ë¥¼ ì°¾ì•„ëƒ„ (í–‰ ë‚´ì—ì„œ ì¸ë±ìŠ¤)
        const allColumns = gridOptions.columnDefs; // ëª¨ë“  ì»¬ëŸ¼ ê°ì²´
        const currentColIndex = allColumns.findIndex(col => col.field === currentCol); // ì»¬ëŸ¼ ì¸ë±ìŠ¤
        const currentRowNode = api.getDisplayedRowAtIndex(currentRowIndex); // í–‰ ì¸ë±ìŠ¤ ê°ì²´

        // --------------- â–¼ F4 ëª¨ë‹¬ â–¼ ------------------
        if (event.event.key === 'F4') {
          if (currentCol === 'accountCode'){
            openAccountModal(currentRowIndex);
            event.event.preventDefault();
            return;
          } else if (currentCol ==='partnerCode') {
            openPartnerModal(currentRowIndex);
            event.event.preventDefault();
            return;
          }
        }
        // --------------- â–² F4 ëª¨ë‹¬ â–² ------------------

        // --------------- â–¼ Ctrl+S ìˆ˜ë™ ì €ì¥ â–¼ ------------------
        if (event.event.ctrlKey && event.event.key === 's') {
          event.event.preventDefault();
          const currentRowData = currentRowNode.data;
          if (validateFullRow(currentRowData)) {
            saveRow(currentRowData);
          } else {
            alert('í•„ìˆ˜ í•„ë“œë¥¼ ëª¨ë‘ ì…ë ¥í•´ì£¼ì„¸ìš”.');
          }
          return;
        }
        // --------------- â–² Ctrl+S ìˆ˜ë™ ì €ì¥ â–² ------------------

        // ë°©í–¥í‚¤ â†“, â†‘ summary row ì´ë™ ì²˜ë¦¬ë§Œ (summary row ì¶”ê°€/ì‚­ì œ X)
        if (event.event.key === 'ArrowDown' || event.event.key === 'ArrowUp') {
          const direction = event.event.key === 'ArrowDown' ? 1 : -1;
          let nextRowIndex = currentRowIndex + direction;
          const colKey = currentCol;
          while (
            nextRowIndex >= 0 &&
            nextRowIndex < api.getDisplayedRowCount() &&
            api.getDisplayedRowAtIndex(nextRowIndex)?.data?.isSummary
          ) {
            nextRowIndex += direction;
          }
          if (nextRowIndex >= 0 && nextRowIndex < api.getDisplayedRowCount() &&
              !api.getDisplayedRowAtIndex(nextRowIndex)?.data?.isSummary) {
            api.setFocusedCell(nextRowIndex, colKey);
            event.event.preventDefault();
          } else {
            event.event.preventDefault();
          }
          return;
        }
        // Enter í‚¤ì¸ì§€ ì²´í¬
        if (event.event.key === 'Enter') {
          // í¸ì§‘ëª¨ë“œ ì§„ì…ì„ ìœ ë°œí•˜ëŠ” ì½”ë“œê°€ ìˆìœ¼ë©´ ì ˆëŒ€ í˜¸ì¶œí•˜ì§€ ì•ŠìŒ!
          event.event.preventDefault();
          event.event.stopPropagation();

          // ì ìš” í•„ë“œì—ì„œ Enter ì‹œ ë‹¤ìŒ í–‰ìœ¼ë¡œ ì´ë™ (íŠ¹ë³„ ì²˜ë¦¬)
          if (currentCol === 'description') {
            // í˜„ì¬ í–‰ì˜ ë°ì´í„°ê°€ ì™„ì „í•˜ë©´ ì €ì¥
            const currentRowData = currentRowNode.data;
            if (validateFullRow(currentRowData)) {
              await saveRow(currentRowData);
            }
            
            let nextRowIndex = currentRowIndex + 1;
            
            // summary row ê±´ë„ˆë›°ê¸°
            while (nextRowIndex < api.getDisplayedRowCount() &&
                  api.getDisplayedRowAtIndex(nextRowIndex)?.data?.isSummary) {
              nextRowIndex++;
            }
            
            // ë‹¤ìŒ ì¼ë°˜ í–‰ì´ ìˆìœ¼ë©´ ê·¸ ì²« ë²ˆì§¸ ì…€ë¡œ ì´ë™
            if (nextRowIndex < api.getDisplayedRowCount()) {
              const nextRowData = api.getDisplayedRowAtIndex(nextRowIndex)?.data;
              if (nextRowData && !nextRowData.isSummary) {
                setTimeout(() => {
                  api.setFocusedCell(nextRowIndex, gridOptions.columnDefs[0].field);
                }, 50);
                return;
              }
            }
            
            // ë‹¤ìŒ ì¼ë°˜ í–‰ì´ ì—†ìœ¼ë©´ ìƒˆ ë¹ˆ í–‰ ì¶”ê°€
            const newEmptyRow = getEmptyRow();
            api.applyTransaction({ add: [newEmptyRow] });
            
            setTimeout(() => {
              // ë§ˆì§€ë§‰ í–‰(ìƒˆë¡œ ì¶”ê°€ëœ í–‰)ì— í¬ì»¤ìŠ¤
              const lastRowIndex = api.getDisplayedRowCount() - 1;
              const lastRowData = api.getDisplayedRowAtIndex(lastRowIndex)?.data;
              
              if (lastRowData && !lastRowData.isSummary) {
                api.setFocusedCell(lastRowIndex, gridOptions.columnDefs[0].field);
              }
            }, 100);
            return;
          }

          // ë‹¤ë¥¸ í•„ë“œì—ì„œ Enter ì‹œ ë‹¤ìŒ editable ì…€ ì°¾ê¸°
          // API ìœ íš¨ì„± ê²€ì‚¬
          if (!api || typeof api.getDisplayedRowCount !== 'function' || 
              typeof api.getDisplayedRowAtIndex !== 'function' ||
              typeof api.setFocusedCell !== 'function') {
            console.error('Enter í‚¤ ì²˜ë¦¬ ì‹œ APIê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
            return;
          }
          
          // currentRowIndexëŠ” ì´ë¯¸ í•¨ìˆ˜ ì‹œì‘ ë¶€ë¶„ì—ì„œ ì„ ì–¸ë¨
          const allColumns = gridOptions.columnDefs;
          const currentColIndex = allColumns.findIndex(col => col.field === event.colDef.field);

          // ë‹¤ìŒ editable ì…€ ì°¾ê¸°
          let nextColIndex = currentColIndex + 1;
          let nextRowIndex = currentRowIndex;
          
          while (true) {
            if (nextColIndex >= allColumns.length) {
              nextColIndex = 0;
              nextRowIndex++;
              if (nextRowIndex >= api.getDisplayedRowCount()) {
                // ë§ˆì§€ë§‰ í–‰ì„ ë„˜ì–´ê°€ë©´ ìƒˆ ë¹ˆ í–‰ ì¶”ê°€
                const newEmptyRow = getEmptyRow();
                api.applyTransaction({ add: [newEmptyRow] });
                
                setTimeout(() => {
                  // ë§ˆì§€ë§‰ í–‰(ìƒˆë¡œ ì¶”ê°€ëœ í–‰)ì— í¬ì»¤ìŠ¤
                  const lastRowIndex = api.getDisplayedRowCount() - 1;
                  const lastRowData = api.getDisplayedRowAtIndex(lastRowIndex)?.data;
                  
                  if (lastRowData && !lastRowData.isSummary) {
                    api.setFocusedCell(lastRowIndex, gridOptions.columnDefs[0].field);
                  }
                }, 100);
                return;
              }
            }
            
            const nextRowNode = api.getDisplayedRowAtIndex(nextRowIndex);
            
            // summary row ê±´ë„ˆë›°ê¸°
            if (nextRowNode?.data?.isSummary) {
              nextRowIndex++;
              nextColIndex = 0;
              continue;
            }
            
            let editable = false;
            if (typeof allColumns[nextColIndex].editable === 'function') {
              editable = allColumns[nextColIndex].editable({ data: nextRowNode.data });
            } else {
              editable = allColumns[nextColIndex].editable;
            }
            
            if (editable) {
              setTimeout(() => {
                api.setFocusedCell(nextRowIndex, allColumns[nextColIndex].field);
              }, 50);
              break;
            }
            nextColIndex++;
          }
          return;
        }
      },
      onCellEditingStopped: (event) => {
        if (enterPressedForMove) {
          enterPressedForMove = false;
          const api = event.api;
          const currentRowIndex = event.node.rowIndex;
          const allColumns = gridOptions.columnDefs;
          const currentColIndex = allColumns.findIndex(col => col.field === event.colDef.field);
          setTimeout(() => {
            api.stopEditing();
            moveToNextEditableCell(api, currentRowIndex, currentColIndex);
          }, 60);
        }
      },
      onCellValueChanged: async (params) => {
        const api = params.api;
        const currentRowIndex = params.node.rowIndex;
        const currentField = params.colDef.field;
        const rowData = params.data;
        // ---------------- â–¼ í•„ìˆ˜ê°’ ëª¨ë‘ ì…ë ¥ì‹œ ìë™ ì €ì¥ â–¼ ----------------
        
        // ê³„ì •ì½”ë“œë‚˜ ê±°ë˜ì²˜ì½”ë“œ ë§¤í•‘ ì‹œì—ëŠ” ìë™ ì €ì¥ í•˜ì§€ ì•ŠìŒ (ë§¤í•‘ ì™„ë£Œ í›„ ê°œë³„ ì²˜ë¦¬)
        if (currentField === 'accountCode' || currentField === 'partnerCode') {
        } else if (validateFullRow(rowData)) {
          saveRow(rowData);
          return; // ìë™ ì €ì¥ í›„ ë‹¤ë¥¸ ì²˜ë¦¬ëŠ” ê±´ë„ˆëœ€
        } else {
        }
        // ---------------- â–² í•„ìˆ˜ê°’ ëª¨ë‘ ì…ë ¥ì‹œ ìë™ ì €ì¥ â–² ----------------

        // ---------------- â–¼ resentmenType ë³€ê²½ ê°ì§€ â–¼ ---------------- 
        if (currentField === 'resentmenType') {
          const newType = params.newValue;
          const data = params.data;

          if (newType === 'g3') { // ì°¨ë³€ì´ë©´
            // credit ê°’ì„ debitìœ¼ë¡œ ì˜®ê¸°ê³  credit ì´ˆê¸°í™”
            if (data.credit > 0) {
              data.debit = data.credit;
              data.credit = 0;
            }
          } else if (newType === 'g4') { // ëŒ€ë³€ì´ë©´
            // debit ê°’ì„ creditìœ¼ë¡œ ì˜®ê¸°ê³  debit ì´ˆê¸°í™”
            if (data.debit > 0) {
              data.credit = data.debit;
              data.debit = 0;
            }
          }
          // ë³€ê²½ëœ ê°’ìœ¼ë¡œ ì…€ ê°•ì œ ë¦¬í”„ë ˆì‹œ
          api.refreshCells({
            rowNodes: [params.node],
            columns: ['debit', 'credit'],
            force: true
          });
        }
        // ---------------- â–² resentmenType ë³€ê²½ ê°ì§€ â–² ---------------- 
        // ---------------- â–¼ ê±°ë˜ì²˜ì½”ë“œ => ê±°ë˜ì²˜ëª… ë§¤í•‘ â–¼ ---------------- 
        if (currentField === 'partnerCode') {
          const partnerCode = params.newValue;
          if (partnerCode) {
            try {
              const response = await fetch(`/acc/pt/${partnerCode}`);
              if (response.ok) {
                const partner = await response.json();
                if (partner?.partnerName) {
                  // ë°ì´í„° ì§ì ‘ ì„¤ì • í›„ ê°•ì œ ì—…ë°ì´íŠ¸
                  params.node.setDataValue('partnerName', partner.partnerName);
                } else {
                  params.node.setDataValue('partnerName', '');
                  alert("í•´ë‹¹ ê±°ë˜ì²˜ëª…ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
                }
              } else {
                params.node.setDataValue('partnerName', '');
                alert("ê±°ë˜ì²˜ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
              }
            } catch (e) {
              console.error(e);
              params.node.setDataValue('partnerName', '');
              alert("ì„œë²„ì™€ í†µì‹  ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
            }
          } else {
            params.node.setDataValue('partnerName', '');
          }
          // partner mapped: trigger saveRow to persist edit
          if (validateFullRow(rowData)) saveRow(rowData);
          return;  // ë§¤í•‘ í›„ ë¶ˆí•„ìš”í•œ ì¶”ê°€ ì €ì¥ ë°©ì§€
        }
        // ---------------- â–² ê±°ë˜ì²˜ì½”ë“œ => ê±°ë˜ì²˜ëª… ë§¤í•‘ â–² ---------------- 
        // ---------------- â–¼ ê³„ì •ê³¼ëª©ì½”ë“œ => ê³„ì •ê³¼ëª©ëª… ë§¤í•‘ â–¼ ---------------- 
        if (currentField === 'accountCode') {
          const accountCode = params.newValue;
          if (accountCode) {
            try {
              const response = await fetch(`/acc/act/${accountCode}`);
              if (response.ok) {
                const account = await response.json();
                if (account?.accountName) {
                  // ë°ì´í„° ì§ì ‘ ì„¤ì • í›„ ê°•ì œ ì—…ë°ì´íŠ¸
                  params.node.setDataValue('accountName', account.accountName);
                } else {
                  params.node.setDataValue('accountName', '');
                  alert("í•´ë‹¹ ê³„ì •ê³¼ëª©ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
                }
              } else {
                params.node.setDataValue('accountName', '');
                alert("ê³„ì •ê³¼ëª© ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
              }
            } catch (e) {
              console.error(e);
              params.node.setDataValue('accountName', '');
              alert("ì„œë²„ì™€ í†µì‹  ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
            }
          } else {
            params.node.setDataValue('accountName', '');
          }
          // account mapped: trigger saveRow to persist edit
          if (validateFullRow(rowData)) saveRow(rowData);
          return;  // ë§¤í•‘ í›„ ë¶ˆí•„ìš”í•œ ì¶”ê°€ ì €ì¥ ë°©ì§€
        }
        // ---------------- â–² ê³„ì •ê³¼ëª©ì½”ë“œ => ê³„ì •ê³¼ëª©ëª… ë§¤í•‘ â–² ----------------
      },
    };
    // ë‚ ì§œ í•„í„° í•¨ìˆ˜
    function filterByDate() {
      // API ìœ íš¨ì„± ê²€ì‚¬
      const api = gridOptions.api;
      if (!api || typeof api.forEachNode !== 'function' || typeof api.applyTransaction !== 'function') {
        console.warn('filterByDate: ê·¸ë¦¬ë“œ APIê°€ ì•„ì§ ì¤€ë¹„ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
        return;
      }

      // ì…ë ¥ê°’ ì½ê¸°
      const startMonth = Number(document.querySelector('input[name="startMonth"]').value);
      const startDay = Number(document.querySelector('input[name="startDay"]').value);
      const endMonth = Number(document.querySelector('input[name="endMonth"]').value);
      const endDay = Number(document.querySelector('input[name="endDay"]').value);

      // ë‚ ì§œ ë²”ìœ„ ê³„ì‚°
      const start = startMonth && startDay ? (startMonth * 100 + startDay) : null;
      const end = endMonth && endDay ? (endMonth * 100 + endDay) : null;

      // rowData í•„í„°ë§
      const filtered = rowData.filter(row => {
        if (!row.month || !row.day) return false;
        const md = row.month * 100 + row.day;
        if (start && md < start) return false;
        if (end && md > end) return false;
        return true;
      });

      // ê·¸ë¦¬ë“œì— ë°˜ì˜ - applyTransaction ì‚¬ìš©
      // 1. ê¸°ì¡´ ëª¨ë“  í–‰ ì œê±°
      const nodesToRemove = [];
      api.forEachNode(node => {
        if (node.data) {
          nodesToRemove.push(node.data);
        }
      });
      
      if (nodesToRemove.length > 0) {
        api.applyTransaction({ remove: nodesToRemove });
      }
      
      // 2. í•„í„°ëœ ë°ì´í„° ì¶”ê°€
      if (filtered.length > 0) {
        api.applyTransaction({ add: filtered });
      }
    }

    // input change ì´ë²¤íŠ¸ ì—°ê²°
    ['startMonth', 'startDay', 'endMonth', 'endDay'].forEach(name => {
      document.querySelector(`input[name="${name}"]`).addEventListener('input', filterByDate);
    });
    // ê·¸ë¦¬ë“œ ìƒì„± (ì´ˆê¸° í¬ì»¤ìŠ¤ ì„¤ì •ì€ onGridReadyì—ì„œ ì²˜ë¦¬)
    const { api, columnApi } = agGrid.createGrid(document.querySelector("#entryGrid"), gridOptions);
    // ------------------------â–¼ ì…€ í¬ì»¤ìŠ¤ ì„¤ì • â–¼------------------------------
    // í˜„ì¬ í–‰ì˜ ë‹¤ìŒ í–‰ ì²« ë²ˆì§¸ ì»¬ëŸ¼(ì²« ë²ˆì§¸ ì…€)ìœ¼ë¡œ í¬ì»¤ìŠ¤ë¥¼ ì´ë™í•˜ê³  í¸ì§‘ ëª¨ë“œë¥¼ ì‹œì‘í•˜ëŠ” í•¨ìˆ˜
    function moveToNextRowFirstCell(api, currentRowIndex) {
      // API ìœ íš¨ì„± ê²€ì‚¬
      if (!api || typeof api.getDisplayedRowCount !== 'function') {
        console.error('moveToNextRowFirstCell: APIê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
        return;
      }
      
      let nextRowIndex = currentRowIndex + 1;
      // ë‹¤ìŒ í–‰ ì¸ë±ìŠ¤ê°€ í˜„ì¬ ë³´ì—¬ì§€ëŠ” í–‰ ê°œìˆ˜ë¥¼ ë„˜ìœ¼ë©´(ë§ˆì§€ë§‰ í–‰ ë‹¤ìŒì´ë¼ë©´)
      if (nextRowIndex >= api.getDisplayedRowCount()) {
        // ìƒˆë¡œìš´ ë¹ˆ í–‰ ì¶”ê°€
        api.applyTransaction({
          add: [getEmptyRow()]
        });
        // ë‹¤ìŒ í–‰ ì¸ë±ìŠ¤ëŠ” ì¶”ê°€ëœ ìƒˆ í–‰ì˜ ë§ˆì§€ë§‰ ì¸ë±ìŠ¤ë¡œ ì„¤ì •
        nextRowIndex = api.getDisplayedRowCount() - 1;
        // 0ms ì§€ì—° í›„, ìƒˆë¡œ ì¶”ê°€ëœ í–‰ì˜ ì²« ë²ˆì§¸ ì»¬ëŸ¼ì— í¬ì»¤ìŠ¤ ì„¤ì • ë° í¸ì§‘ ì‹œì‘
        setTimeout(() => {
          // ìƒˆë¡œ ì¶”ê°€ëœ ë¹ˆ í–‰ì„ ì°¾ì•„ì„œ ì²« ë²ˆì§¸ ì…€ì— í¬ì»¤ìŠ¤
          for (let i = 0; i < api.getDisplayedRowCount(); i++) {
            const row = api.getDisplayedRowAtIndex(i)?.data;
            if (row && isEmptyRow(row)) {
              api.setFocusedCell(i, gridOptions.columnDefs[0].field);
              break;
            }
          }
        }, 50);
        return;
      }
      // ë‹¤ìŒ í–‰ì˜ ì²« ë²ˆì§¸ ì»¬ëŸ¼ì— í¬ì»¤ìŠ¤ ì„¤ì • ë° í¸ì§‘ ì‹œì‘
      api.setFocusedCell(nextRowIndex, gridOptions.columnDefs[0].field);
    }
    // í˜„ì¬ ì…€ì—ì„œ ë‹¤ìŒ í¸ì§‘ ê°€ëŠ¥í•œ ì…€ë¡œ í¬ì»¤ìŠ¤ë¥¼ ì´ë™í•˜ëŠ” í•¨ìˆ˜
    // í–‰ê³¼ ì—´ì„ ìˆœíšŒí•˜ë©° í¸ì§‘ ê°€ëŠ¥í•œ ì»¬ëŸ¼ì„ ì°¾ì•„ ì´ë™
    // ë§Œì•½ ë§ˆì§€ë§‰ ì…€ ì´í›„ë©´ ìƒˆë¡œìš´ ë¹ˆ í–‰ì„ ì¶”ê°€í•˜ê³  ì²« í¸ì§‘ ê°€ëŠ¥í•œ ì…€ë¡œ ì´ë™
    function moveToNextEditableCell(api, currentRowIndex, currentColIndex) {
      // API ìœ íš¨ì„± ê²€ì‚¬
      if (!api || typeof api.getDisplayedRowCount !== 'function') {
        console.error('moveToNextEditableCell: APIê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
        return;
      }
      
      const allColumns = gridOptions.columnDefs;
      let nextColIndex = currentColIndex + 1;
      let nextRowIndex = currentRowIndex;
      let found = false;
      while (true) {
        if (nextColIndex >= allColumns.length) {
          nextColIndex = 0;
          nextRowIndex++;
          if (nextRowIndex >= api.getDisplayedRowCount()) {
            break;
          }
        }
        const nextRowNode = api.getDisplayedRowAtIndex(nextRowIndex);
        if (nextRowNode?.data?.isSummary) {
          nextRowIndex++;
          nextColIndex = 0;
          if (nextRowIndex >= api.getDisplayedRowCount()) break;
          continue;
        }
        if (nextRowNode && !nextRowNode.data.entryNumber && !nextRowNode.data.lineNumber) {
          if (nextColIndex < allColumns.length) {
            api.stopEditing(); // ì…€ í¸ì§‘ ì¢…ë£Œ
            setTimeout(() => {
              api.setFocusedCell(nextRowIndex, allColumns[nextColIndex].field);
            }, 0);
          } else {
            api.stopEditing();
            api.applyTransaction({ add: [getEmptyRow()] });
            setTimeout(() => {
              // ìƒˆë¡œ ì¶”ê°€ëœ ë¹ˆ í–‰ì„ ì°¾ì•„ì„œ ì²« ë²ˆì§¸ ì…€ì— í¬ì»¤ìŠ¤
              for (let i = 0; i < api.getDisplayedRowCount(); i++) {
                const row = api.getDisplayedRowAtIndex(i)?.data;
                if (row && isEmptyRow(row)) {
                  api.setFocusedCell(i, gridOptions.columnDefs[0].field);
                  break;
                }
              }
            }, 50);
          }
          return;
        }
        const nextCol = allColumns[nextColIndex];
        let editable = false;
        if (typeof nextCol.editable === 'function') {
          editable = nextCol.editable({ data: nextRowNode.data });
        } else {
          editable = nextCol.editable;
        }
        if (editable) {
          found = true;
          break;
        }
        nextColIndex++;
      }
      if (found) {
        setTimeout(() => {
          api.setFocusedCell(nextRowIndex, allColumns[nextColIndex].field);
        }, 0);
      } else {
        for (let i = 0; i < api.getDisplayedRowCount(); i++) {
          const row = api.getDisplayedRowAtIndex(i)?.data;
          if (row && isEmptyRow(row) && !row.isSummary) {
            api.setFocusedCell(i, allColumns[0].field);
            return;
          }
        }
        api.applyTransaction({ add: [getEmptyRow()] });
        setTimeout(() => {
          // ìƒˆë¡œ ì¶”ê°€ëœ ë¹ˆ í–‰ì„ ì°¾ì•„ì„œ ì²« ë²ˆì§¸ ì…€ì— í¬ì»¤ìŠ¤
          for (let i = 0; i < api.getDisplayedRowCount(); i++) {
            const row = api.getDisplayedRowAtIndex(i)?.data;
            if (row && isEmptyRow(row)) {
              api.setFocusedCell(i, gridOptions.columnDefs[0].field);
              break;
            }
          }
        }, 50);
      }
    }
    // ------------------------â–² ì…€ í¬ì»¤ìŠ¤ ì„¤ì • â–²------------------------------
    // ìƒˆë¡œìš´ í–‰ì„ ì¶”ê°€í•  ë•Œ ì´ˆê¸°ê°’ í•¨ìˆ˜
    function getEmptyRow() {
      const emptyRow = {
        month: null,
        day: null,
        entryNumber: null,
        resentmenType: '',
        accountCode: '',
        accountName: '',
        partnerCode: '',
        partnerName: '',
        debit: null,
        credit: null,
        description: '',
        lineNumber: null
      };
      // ìœ ë‹ˆí¬í•œ ID ë¯¸ë¦¬ í• ë‹¹ (ë” ì•ˆì „í•œ ID ìƒì„±)
      emptyRow._emptyRowId = `empty_row_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      return emptyRow;
    }
    // ------------------------â–¼ ì‚­ì œ â–¼------------------------------
    // ì²´í¬í•œ í–‰ ì‚­ì œ
    function deleteSelectedRow() {
      const selectedNodes = gridOptions.api.getSelectedNodes(); // í˜„ì¬ ì„ íƒëœ í–‰ ë°ì´í„°ë¥¼ ê°€ì ¸ì˜¤ê¸°
      if (selectedNodes.length === 0) { 
        alert("ì‚­ì œí•  í–‰ì„ ì„ íƒí•˜ì„¸ìš”.");
        return;
      }

      // ì‚­ì œ í™•ì¸ ë‹¤ì´ì–¼ë¡œê·¸
      const confirmMessage = `ì„ íƒëœ ${selectedNodes.length}ê°œ í–‰ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`;
      if (!confirm(confirmMessage)) {
        return; // ì‚¬ìš©ìê°€ ì·¨ì†Œí•œ ê²½ìš°
      }

      // ì‚­ì œí•  ë°ì´í„°ë§Œ ì¶”ì¶œ (selectedNodes.data ë°°ì—´)
      const deleteData = selectedNodes.map(node => node.data);

      fetch(`/acc/en/del`, {
        method: 'PUT',
        headers: {'Content-Type': 'application/json' },
        body: JSON.stringify(deleteData)
      })
      .then(response => { // DB ì²˜ë¦¬ ì‘ë‹µ ê²°ê³¼
        if (response.ok) { 
          // DB ì‚­ì œ ì„±ê³µì‹œ í™”ë©´ì—ì„œ ì‚­ì œ - setTimeoutìœ¼ë¡œ ì•ˆì „í•˜ê²Œ ì²˜ë¦¬
          setTimeout(() => {
            try {
              // ì„ íƒëœ ë…¸ë“œë“¤ì„ ì§ì ‘ ì œê±° (ë°ì´í„°ê°€ ì•„ë‹Œ ë…¸ë“œ ê¸°ì¤€ìœ¼ë¡œ)
              const nodesToRemove = selectedNodes.map(node => node.data);
              
              gridOptions.api.applyTransaction({ remove: nodesToRemove });
              
              updateFirstDiffEntryNumber();
            } catch (removeError) {
              console.error('ê·¸ë¦¬ë“œì—ì„œ í–‰ ì œê±° ì¤‘ ì˜¤ë¥˜:', removeError);
              // ì˜¤ë¥˜ê°€ ë°œìƒí•˜ë©´ ì „ì²´ ë°ì´í„°ë¥¼ ë‹¤ì‹œ ë¡œë“œ
              location.reload();
            }
          }, 0);
        } else {
          return Promise.reject(response.statusText);
        }
      })
      .catch(err => {
        console.error('ì‚­ì œ ì‹¤íŒ¨:', err);
        alert("Delete failed: " + err);
      });
    }
    // ------------------------â–² ì‚­ì œ â–²------------------------------

    // ------------------------â–¼ ì €ì¥ â–¼------------------------------
    // ag-Grid ë°ì´í„° íŒŒì‹± -> EntryMasterDTO + details ë³€í™˜
    function parseGridDataForSave(rows, isNew) {
      
      if (!rows || rows.length === 0) {
        console.error('parseGridDataForSave: rowsê°€ ë¹„ì–´ìˆìŒ');
        return null;
      }

      const firstRow = rows[0];
      
      const entryNumber = firstRow.entryNumber || 0; // ì „í‘œë²ˆí˜¸
      const now = new Date(); // ì˜¤ëŠ˜ë‚ ì§œ 
      const year = entryYear; // ë…„ë„

      const entryMaster = {
        entryNumber: entryNumber, // ì „í‘œë²ˆí˜¸
        entryType: 'ì¼ë°˜', // ì „í‘œêµ¬ë¶„
        entryDate: new Date(year, Number(firstRow.month) - 1, Number(firstRow.day)), // ì „í‘œì¼ì
        entryStatus: 'a2', // ë§ˆê°ì—¬ë¶€ ë¶€
        creator: loginUser, // ì‘ì„±ì
        updatedAt: now,
        transactionType: 63, // ê³¼ì„¸êµ¬ë¶„ ì¼ë°˜
        electronicType: 'a2', // ì „ìì—¬ë¶€ ë¶€
        totalSupplyAmount: 0, // ê³µê¸‰ê°€ì•¡
        totalTaxAmount: 0, // ë¶€ê°€ì„¸
        details: [] // ì „í‘œ ìƒì„¸
      };
      if (isNew) {
        entryMaster.createdAt = now;
      }

      rows.forEach(value => {
        const amount = Number(value.debit) > 0 ? Number(value.debit) : Number(value.credit); // ê¸ˆì•¡
        
        const detail = {
          lineNumber: value.lineNumber, // ìˆœë²ˆ
          entryNumber: entryNumber, // ì „í‘œë²ˆí˜¸
          partnerCode: value.partnerCode || null, // ê±°ë˜ì²˜ì½”ë“œ
          partnerName: value.partnerName || null, // ê±°ë˜ì²˜ëª…
          accountCode: value.accountCode, // ê³„ì •ê³¼ëª©ì½”ë“œ
          accountName: value.accountName || null, // ê³„ì •ê³¼ëª©ëª… (ë§¤í•‘ëœ ê°’ í¬í•¨)
          resentmenType: value.resentmenType, // ë¶„ê°œêµ¬ë¶„
          amount: amount, // ê¸ˆì•¡
          description: value.description || null, // ì ìš”
          updatedAt: now
        };
        if (isNew) {
          detail.createdAt = now;
        }
        entryMaster.details.push(detail);
      });
      
      return entryMaster;
    }
    // ìë™ DB ì €ì¥
    async function saveRow(rowData) {
      const isNew = !rowData.lineNumber;
      
      let method = isNew ? 'POST' : 'PUT';
      let data;

      if (isNew) {
        if (firstDiffEntryNumber) {
          rowData.entryNumber = firstDiffEntryNumber;
        } else {
          rowData.entryNumber = enNo;
        }
        
        rowData.lineNumber = await selectLineNo(rowData.entryNumber);
        
        data = parseGridDataForSave([rowData], isNew);
      } else {
        const entryNumberToUpdate = rowData.entryNumber;
        const rowsToUpdate = [];
        gridOptions.api.forEachNode(node => {
          if (node.data && node.data.entryNumber === entryNumberToUpdate) {
            rowsToUpdate.push(node.data);
          }
        });
        data = parseGridDataForSave(rowsToUpdate, isNew);
      }

      if (!data) {
        console.error("No data to save.");
        return;
      }
      
      fetch('/acc/en', {
        method: method,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
      })
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return response.json();
      })
      .then(savedMaster => {
        const api = gridOptions.api;

        if (!savedMaster || !savedMaster.details || !Array.isArray(savedMaster.details)) {
          console.error("Invalid data received from server:", savedMaster);
          return;
        }

        const receivedRows = savedMaster.details.map(d => {
          // ë‚ ì§œ ì•ˆì „í•˜ê²Œ íŒŒì‹±
          const entryDate = new Date(savedMaster.entryDate);
          const isValidDate = !isNaN(entryDate.getTime());
          
          return {
            year: isValidDate ? entryDate.getFullYear() : new Date().getFullYear(),
            month: isValidDate ? entryDate.getMonth() + 1 : new Date().getMonth() + 1,
            day: isValidDate ? entryDate.getDate() : new Date().getDate(),
            entryNumber: savedMaster.entryNumber,
            resentmenType: d.resentmenType,
            accountCode: d.accountCode,
            accountName: d.accountName || '',  // ì„œë²„ì—ì„œ ë°›ì€ ê°’ ì‚¬ìš© (ì´ì œ ë§¤í•‘ê°’ì´ í¬í•¨ë¨)
            partnerCode: d.partnerCode || '',
            partnerName: d.partnerName || '',  // ì„œë²„ì—ì„œ ë°›ì€ ê°’ ì‚¬ìš© (ì´ì œ ë§¤í•‘ê°’ì´ í¬í•¨ë¨)
            debit: d.resentmenType === 'g3' ? d.amount : null,
            credit: d.resentmenType === 'g4' ? d.amount : null,
            description: d.description || '',
            lineNumber: d.lineNumber
          };
        });

        if (isNew) {
          const newRowDataFromServer = receivedRows[0];
          let emptyRowNode = null;
          api.forEachNode(node => {
            if (node.data && node.data._emptyRowId === rowData._emptyRowId) {
              emptyRowNode = node;
            }
          });

          if (emptyRowNode) {
            emptyRowNode.setData(newRowDataFromServer);
          } else {
            api.applyTransaction({ add: [newRowDataFromServer] });
          }

          // ì‹ ê·œ ì €ì¥ í›„ ë¹ˆ í–‰ í™•ì¸ ë° ì¶”ê°€
          let hasEmptyRow = false;
          api.forEachNode(node => { 
            if (node.data && isEmptyRow(node.data)) {
              hasEmptyRow = true;
            }
          });
          
          if (!hasEmptyRow) {
            api.applyTransaction({ add: [getEmptyRow()] });
          }

          // ë¹ˆ í–‰ì— í¬ì»¤ìŠ¤ ì„¤ì •
          setTimeout(() => {
            let focusSet = false;
            api.forEachNode(node => {
              if (node.data && isEmptyRow(node.data) && !focusSet) {
                api.setFocusedCell(node.rowIndex, gridOptions.columnDefs[0].field);
                focusSet = true;
              }
            });
            
            if (!focusSet) {
            }
          }, 100);
        } else {
          api.applyTransaction({ update: receivedRows });
        }
        updateFirstDiffEntryNumber();
      })
      .catch(err => {
        console.error('Save error:', err);
        console.error('Request data:', data);
        alert((isNew ? "Insert" : "Update") + " failed: " + err.message);
      });
    }
    // ------------------------â–² ì €ì¥ â–²------------------------------

    // ------------------------â–¼ ëª¨ë‹¬ â–¼------------------------------
    let currentCellForModal = null; // í˜„ì¬ F4ë¡œ ì—´ë¦° ì…€ ì •ë³´
    // ê³„ì •ê³¼ëª© ëª¨ë‹¬
    let accountModalInstance = null;
    // ê³„ì •ê³¼ëª© ëª¨ë‹¬ AG Grid
    const accountGridOptions = {
      headerHeight: 35,
      rowHeight: 35,
      columnDefs: [
        { headerName: "ì½”ë“œ", field: "accountCode", sortable: true, filter: true },
        { headerName: "ê³„ì •ê³¼ëª©ëª…", field: "accountName", sortable: true, filter: true }
      ],
      rowSelection: { mode: 'singleRow' },
      defaultColDef: {
        flex: 1,
        minWidth: 100,
        resizable: true,
      },
      onRowDoubleClicked: (event) => {
        selectAccount(event.data.accountCode, event.data.accountName);
      }
    };
    // ê³„ì •ê³¼ëª© ëª¨ë‹¬ ì—´ê¸°
    function openAccountModal(rowIndex) {
      currentCellForModal = { rowIndex };
      if (!accountGridOptions.api) {
        agGrid.createGrid(document.getElementById('accountGrid'), accountGridOptions);
        // loadAccountData() ëŠ” onGridReady ì—ì„œ í˜¸ì¶œ
      } else {
        loadAccountData(); // ì´ë¯¸ ì¤€ë¹„ë˜ì—ˆìœ¼ë©´ ìƒˆë¡œ ë°ì´í„° ë¡œë“œ
      }

      if (!accountModalInstance) {
        accountModalInstance = new bootstrap.Modal(document.getElementById('accountModal'));
      }
      accountModalInstance.show();
    }
    // ê³„ì •ê³¼ëª© ë°ì´í„° ë¡œë“œ
    function loadAccountData() {
      fetch('/acc/act/list')
        .then(res => {
          if (!res.ok) throw new Error('ê³„ì •ê³¼ëª© API í˜¸ì¶œ ì‹¤íŒ¨');
          return res.json();
        })
        .then(data => {
          if (accountGridOptions.api) {
            // ê¸°ì¡´ ë°ì´í„° ì œê±°í•˜ê³  ìƒˆ ë°ì´í„° ì¶”ê°€
            accountGridOptions.api.applyTransaction({
              add: data
            });
            accountGridOptions.api.sizeColumnsToFit();
          } else {
            console.warn('Account Grid API not ready; data load deferred');
          }
        })
        .catch(err => {
          console.error(err);
          alert('ê³„ì •ê³¼ëª© ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
        });
    }
    // ê³„ì •ê³¼ëª© onGridReady
    accountGridOptions.onGridReady = function(params) {
      accountGridOptions.api = params.api;
      loadAccountData(); // onGridReady ì‹œì ì— ë°ì´í„° ë¡œë“œ
    };
    // ê³„ì •ê³¼ëª© ì„ íƒ ì‹œ ë©”ì¸ ê·¸ë¦¬ë“œì— ê°’ ì„¸íŒ…
    function selectAccount(code, name) {
      if (currentCellForModal && gridOptions.api) {
        const node = gridOptions.api.getDisplayedRowAtIndex(currentCellForModal.rowIndex);
        if (node) {
          // ë°ì´í„° íƒ€ì… ì—ëŸ¬ë¥¼ ë°©ì§€í•˜ê¸° ìœ„í•´ ë¬¸ìì—´ë¡œ ë³€í™˜
          node.setDataValue('accountCode', String(code));
          node.setDataValue('accountName', String(name));
        }
      }
      if (accountModalInstance) accountModalInstance.hide();
    }
    // ê±°ë˜ì²˜ ëª¨ë‹¬ 
    let partnerModalInstance = null;
    // ê±°ë˜ì²˜ ëª¨ë‹¬ AG Grid
    const partnerGridOptions = {
      headerHeight: 35,
      rowHeight: 35,
      columnDefs: [
        { headerName: "ì½”ë“œ", field: "partnerCode", sortable: true, filter: true },
        { headerName: "ê±°ë˜ì²˜ëª…", field: "partnerName", sortable: true, filter: true }
      ],
      rowSelection: { mode: 'singleRow' },
      defaultColDef: {
        flex: 1,
        minWidth: 100,
        resizable: true,
      },
      onRowDoubleClicked: (event) => {
        selectPartner(event.data.partnerCode, event.data.partnerName);
      }
    };
    // ê±°ë˜ì²˜ ëª¨ë‹¬ ì—´ê¸°
    function openPartnerModal(rowIndex) {
      currentCellForModal = { rowIndex };
      if (!partnerGridOptions.api) {
        agGrid.createGrid(document.getElementById('partnerGrid'), partnerGridOptions);
        // loadPartnerData() ëŠ” onGridReady ì•ˆì—ì„œ í˜¸ì¶œë˜ë„ë¡ ì´ë¯¸ ì²˜ë¦¬ë¨
      } else {
        loadPartnerData();  // ì´ë¯¸ ì¤€ë¹„ëœ ê²½ìš°ì—ë§Œ ë¡œë“œ
      }

      if (!partnerModalInstance) {
        partnerModalInstance = new bootstrap.Modal(document.getElementById('partnerModal'));
      }
      partnerModalInstance.show();
    }
    // ê±°ë˜ì²˜ ë°ì´í„° ë¡œë“œ
    function loadPartnerData() {
      fetch('/acc/pt/list')
        .then(res => {
          if (!res.ok) throw new Error('ê±°ë˜ì²˜ API í˜¸ì¶œ ì‹¤íŒ¨');
          return res.json();
        })
        .then(data => {
          if (partnerGridOptions.api) {
            // ê¸°ì¡´ ë°ì´í„°ëŠ” ì œê±°í•˜ê³  ìƒˆ ë°ì´í„° ì¶”ê°€
            partnerGridOptions.api.setRowData?.([]);  // êµ¬ë²„ì „ í˜¸í™˜ìš©, ìˆìœ¼ë©´ ì´ˆê¸°í™”
            partnerGridOptions.api.applyTransaction({
              add: data
            });
            partnerGridOptions.api.sizeColumnsToFit();
          } else {
            console.warn('Grid API not ready; data load deferred');
          }
        })
        .catch(err => {
          console.error(err);
          alert('ê±°ë˜ì²˜ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
        });
    }
    // ê±°ë˜ì²˜ onGridReady
    partnerGridOptions.onGridReady = function(params) {
      partnerGridOptions.api = params.api;
      loadPartnerData();  // onGridReady ì‹œì ì—ì„œ ë°ì´í„° ë¡œë“œ
    };
    // ê±°ë˜ì²˜ ì„ íƒ ì‹œ ë©”ì¸ ê·¸ë¦¬ë“œì— ê°’ ì„¸íŒ…
    function selectPartner(code, name) {
      if (currentCellForModal && gridOptions.api) {
        const node = gridOptions.api.getDisplayedRowAtIndex(currentCellForModal.rowIndex);
        if (node) {
          // ë°ì´í„° íƒ€ì… ì—ëŸ¬ë¥¼ ë°©ì§€í•˜ê¸° ìœ„í•´ ë¬¸ìì—´ë¡œ ë³€í™˜
          node.setDataValue('partnerCode', String(code));
          node.setDataValue('partnerName', String(name));
        }
      }
      if (partnerModalInstance) partnerModalInstance.hide();
    }
    // ------------------------â–² ëª¨ë‹¬ â–²------------------------------

    // Summary row ì¦‰ì‹œ ìƒì„± ë° ì¶”ê°€ í•¨ìˆ˜
    function generateAndAddSummaryRow(entryNumber) {
      const currentApi = gridOptions.api;
      if (!currentApi || typeof currentApi.getDisplayedRowCount !== 'function' || 
          typeof currentApi.applyTransaction !== 'function') {
        console.error('generateAndAddSummaryRow: APIê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
        return;
      }
      
      setTimeout(() => {
        try {
          // 1. ë¨¼ì € í˜„ì¬ ê·¸ë¦¬ë“œì— í•´ë‹¹ ì „í‘œë²ˆí˜¸ì˜ summary rowê°€ ì´ë¯¸ ìˆëŠ”ì§€ í™•ì¸
          let existingSummaryCount = 0;
          for (let i = 0; i < currentApi.getDisplayedRowCount(); i++) {
            const rowData = currentApi.getDisplayedRowAtIndex(i)?.data;
            if (rowData && rowData.isSummary === true && rowData._summaryEntryNumber === entryNumber) {
              existingSummaryCount++;
              console.warn('ì´ë¯¸ ì¡´ì¬í•˜ëŠ” summary row ë°œê²¬:', {
                index: i,
                entryNumber: entryNumber,
                isSummaryType: rowData.isSummaryType,
                month: rowData.month
              });
            }
          }
          
          if (existingSummaryCount > 0) {
            console.warn(`ì „í‘œë²ˆí˜¸ ${entryNumber}ì˜ summary rowê°€ ì´ë¯¸ ${existingSummaryCount}ê°œ ì¡´ì¬í•¨. ìƒì„± ì¤‘ë‹¨.`);
            return;
          }
          
          // 2. ì „ì²´ ë°ì´í„° ìˆ˜ì§‘ (summary row ì œì™¸, ë¹ˆ í–‰ í¬í•¨)
          let allRowData = [];
          for (let i = 0; i < currentApi.getDisplayedRowCount(); i++) {
            const rowData = currentApi.getDisplayedRowAtIndex(i)?.data;
            if (rowData && !rowData.isSummary) {
              allRowData.push(rowData);
            }
          }
          
          // 3. summary row ìƒì„±
          const summaryRows = generateSummaryRow(allRowData, entryNumber);
          
          if (summaryRows && summaryRows.length > 0) {
            // 4. í•´ë‹¹ ì „í‘œë²ˆí˜¸ì˜ ë§ˆì§€ë§‰ ìœ„ì¹˜ ì°¾ê¸°
            let insertPosition = -1;
            for (let i = 0; i < currentApi.getDisplayedRowCount(); i++) {
              const rowData = currentApi.getDisplayedRowAtIndex(i)?.data;
              if (rowData && !rowData.isSummary && rowData.entryNumber === entryNumber) {
                insertPosition = i + 1;
              }
            }
            
            // 5. summary row ì¶”ê°€
            try {
              if (insertPosition >= 0 && insertPosition <= currentApi.getDisplayedRowCount()) {
                currentApi.applyTransaction({ 
                  add: summaryRows, 
                  addIndex: insertPosition 
                });
              } else {
                // ì „í‘œë²ˆí˜¸ í–‰ì„ ì°¾ì§€ ëª»í•œ ê²½ìš° ë§¨ ëì— ì¶”ê°€
                currentApi.applyTransaction({ add: summaryRows });
              }
              
              // ì¶”ê°€ í›„ ê·¸ë¦¬ë“œ ìƒíƒœ í™•ì¸
            } catch (addError) {
              console.error('Summary row ì¶”ê°€ ì¤‘ ì˜¤ë¥˜:', addError);
            }
          }
          
        } catch (error) {
          console.error('generateAndAddSummaryRow ì¤‘ ì˜¤ë¥˜:', error);
        }
      }, 0);
    }
      // Summary row ì œê±° í—¬í¼ í•¨ìˆ˜
    function removeSummaryRows(api) {
      // API ê¸°ë³¸ ìœ íš¨ì„± ê²€ì‚¬
      if (!api) {
        console.error('removeSummaryRows: APIê°€ null/undefinedì…ë‹ˆë‹¤.');
        return Promise.resolve();
      }
      
      // API ë©”ì„œë“œë“¤ì˜ ì¡´ì¬ ì—¬ë¶€ í™•ì¸
      if (typeof api.getDisplayedRowCount !== 'function' || 
          typeof api.getDisplayedRowAtIndex !== 'function' ||
          typeof api.applyTransaction !== 'function') {
        console.error('removeSummaryRows: í•„ìš”í•œ API ë©”ì„œë“œë“¤ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
        return Promise.resolve();
      }
      
      return new Promise((resolve) => {
        setTimeout(() => {
          let summaryRowsToRemove = [];
          
          try {
            // í•œ ë²ˆ ë” API ë©”ì„œë“œ ìœ íš¨ì„± í™•ì¸ (ì‹¤í–‰ ì§ì „)
            if (typeof api.getDisplayedRowCount !== 'function') {
              console.error('removeSummaryRows: getDisplayedRowCountê°€ í•¨ìˆ˜ê°€ ì•„ë‹™ë‹ˆë‹¤.');
              resolve();
              return;
            }
            
            const rowCount = api.getDisplayedRowCount();
            
            for (let i = 0; i < rowCount; i++) {
              const rowNode = api.getDisplayedRowAtIndex(i);
              if (!rowNode || !rowNode.data) continue;
              
              const rowData = rowNode.data;
              // isSummary === trueì´ê³  ë¹ˆ í–‰ì´ ì•„ë‹Œ ê²½ìš°ë§Œ ì œê±° ëŒ€ìƒìœ¼ë¡œ ì„ ì •
              if (rowData.isSummary === true && 
                  (rowData.isSummaryType === 'subtotal' || rowData.isSummaryType === 'total')) {
                summaryRowsToRemove.push(rowData);
              }
            }
          } catch (error) {
            console.error('Summary row ê²€ìƒ‰ ì¤‘ ì˜¤ë¥˜:', error);
            resolve();
            return;
          }
          
          if (summaryRowsToRemove.length > 0) {
            try {
              // ëª¨ë“  summary rowë¥¼ í•œ ë²ˆì— ì œê±°
              api.applyTransaction({ remove: summaryRowsToRemove });
              
              // ag-Gridê°€ ì œê±° ì‘ì—…ì„ ì™„ì „íˆ ì²˜ë¦¬í•  ì‹œê°„ì„ ì£¼ê¸° ìœ„í•´ ì•½ê°„ì˜ ì§€ì—°
              setTimeout(() => {
                resolve();
              }, 50);
            } catch (error) {
              console.error('Summary row ì œê±° ì¤‘ ì˜¤ë¥˜:', error);
              // ì œê±° ì‹¤íŒ¨ ì‹œ ê°œë³„ ì œê±° ì‹œë„
              let removeCount = 0;
              summaryRowsToRemove.forEach((row, index) => {
                try {
                  api.applyTransaction({ remove: [row] });
                  removeCount++;
                } catch (individualError) {
                  console.error(`Summary row ${index + 1} ê°œë³„ ì œê±° ì‹¤íŒ¨:`, individualError);
                }
              });
              
              // ê°œë³„ ì œê±° ì™„ë£Œ í›„ ì§€ì—°
              setTimeout(() => {
                resolve();
              }, 50);
            }
          } else {
            resolve();
          }
        }, 0);
      });
    }
    
    //ì†Œê³„/ì°¨ì•¡ ê³„ì‚° í•¨ìˆ˜
    function generateSummaryRow(rowData, entryNumber) {
      // partnerNameì—´ì— ì°¨ì•¡ í‘œì‹œ
      let subtotal = { partnerName: 0, debit: 0, credit: 0 }; // ì „í‘œ ì†Œê³„
      let grandTotal = { partnerName: 0, debit: 0, credit: 0 }; // í•©ê³„

      // ì†Œê³„í–‰ ê³„ì‚°í•˜ëŠ” forEach
      rowData.forEach(data=> {
        // ì „í‘œ ì†Œê³„ ëˆ„ì (entryNumberê°€ ì¼ì¹˜í•˜ë©´)
        if (data.entryNumber === entryNumber) {
          subtotal.debit += Number(data.debit) || 0;
          subtotal.credit += Number(data.credit) || 0;
        }
        // í•©ê³„ ëˆ„ì 
        grandTotal.debit += Number(data.debit) || 0;
        grandTotal.credit += Number(data.credit) || 0;
      });
      // ì°¨ì•¡(ì ˆëŒ“ê°’ ì°¨ì´) ê³„ì‚°
      const subtotalDiff = Math.abs(subtotal.debit - subtotal.credit);
      const grandTotalDiff = Math.abs(grandTotal.debit - grandTotal.credit);

      // ì†Œê³„í–‰ë§Œ ë°˜í™˜ (í•©ê³„í–‰ì€ ì„ì‹œë¡œ ì œê±°í•˜ì—¬ ID ì¶©ëŒ ë¬¸ì œ í•´ê²°)
      const summaryRowsResult = [
        {
          month: `ì†Œê³„(${entryNumber})`,
          day: '',
          entryNumber: '',
          resentmenType: '',
          accountCode: '',
          accountName: 'â”€â”€ ì†Œ ê³„ â”€â”€',
          partnerCode: '',
          partnerName: `ì°¨ì•¡: ${subtotalDiff.toLocaleString()}`,
          debit: subtotal.debit.toLocaleString(),
          credit: subtotal.credit.toLocaleString(),
          description: '',
          lineNumber: null,
          isSummary: true,
          isSummaryType: 'subtotal',
          _summaryEntryNumber: entryNumber // ì†Œì† ì „í‘œë²ˆí˜¸ ì¶”ê°€
        }
        // í•©ê³„í–‰ì€ ì„ì‹œë¡œ ì œê±° (ID ì¶©ëŒ ë¬¸ì œ í•´ê²° í›„ ë‹¤ì‹œ ì¶”ê°€ ì˜ˆì •)
        // {
        //   month: 'í•©ê³„',
        //   day: '',
        //   entryNumber: '',
        //   resentmenType: '',
        //   accountCode: '',
        //   accountName: 'â”€â”€ í•© ê³„ â”€â”€',
        //   partnerCode: '',
        //   partnerName: `ì°¨ì•¡: ${grandTotalDiff.toLocaleString()}`,
        //   debit: grandTotal.debit.toLocaleString(),
        //   credit: grandTotal.credit.toLocaleString(),
        //   description: '',
        //   lineNumber: null,
        //   isSummary: true,
        //   isSummaryType: 'total',
        //   _summaryEntryNumber: entryNumber // ì†Œì† ì „í‘œë²ˆí˜¸ ì¶”ê°€
        // }
      ];
      
      return summaryRowsResult;
    }
    function findFirstDiffEntryNumber() {
      const entrySums = {};
      rowData.forEach(row => {
        if (!row.entryNumber || row.isSummary) return;
        if (!entrySums[row.entryNumber]) entrySums[row.entryNumber] = { debit: 0, credit: 0 };
        entrySums[row.entryNumber].debit += Number(row.debit) || 0;
        entrySums[row.entryNumber].credit += Number(row.credit) || 0;
      });
      for (const entryNumber of Object.keys(entrySums)) {
        const { debit, credit } = entrySums[entryNumber];
        if (Math.abs(debit - credit) > 0) {
          return entryNumber;
        }
      }
      return null;
    }
    function updateFirstDiffEntryNumber() {
      firstDiffEntryNumber = findFirstDiffEntryNumber();
    }
// ê°™ì€ ì „í‘œë²ˆí˜¸ë¥¼ ê°€ì§„ í–‰ë“¤ ê°•ì¡° í‘œì‹œ
    function highlightSameEntryNumber(entryNumber) {
      if (entryNumber && entryNumber !== highlightedEntryNumber) {
        highlightedEntryNumber = entryNumber;
        if (gridOptions.api) {
          gridOptions.api.redrawRows();
        }
      }
    }
    
    // ê°•ì¡° í‘œì‹œ í•´ì œ
    function clearHighlight() {
      if (highlightedEntryNumber) {
        highlightedEntryNumber = null;
        if (gridOptions.api) {
          gridOptions.api.redrawRows();
        }
      }
    }
    
    // ë¹ˆ í–‰ì¸ì§€ í™•ì¸í•˜ëŠ” í•¨ìˆ˜
    function isEmptyRow(rowData) {
      return !rowData.entryNumber && !rowData.lineNumber && 
             (!rowData.month || !rowData.day || !rowData.resentmenType || !rowData.accountCode);
    }
  </script>
</div>