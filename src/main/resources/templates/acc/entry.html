<html xmlns:th="http://www.thymeleaf.org" xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout" layout:decorate="~{common/layouts/default}">
<!-- ============================================
  - 작성자   : 김희정
  - 최초작성 : 2025-06-18
  - 설명     : 일반전표 화면
  -----------------------------------------------
  [ 변경 이력 ]
  - 2025-06-18 (김희정): title 및 내용 추가
  - 2025-06-20 (김희정): 레이아웃 및 ag-grid 세팅(enter 이동/ 삭제(view))
  - 2025-06-23 (김희정): DB 연결 (select)
                       : 구분 field 번호로 입력하면 자동으로 매칭 1:출금 2:입금 3:차변 4:대변
                       : 숫자 천단위 데이터 포맷
                       : editable가 flase인 셀은 포커스 제외
                       : 필수 값 입력 안하면 행 저장 불가 (날짜,차대변,계정과목코드,금액)
                       : 가장 아래 입력할수 있는 칸 추가
                       : 거래처 코드 입력하면 거래처명 불러오기
  -----------------------------------------------
  [ TODO ] 
  1. DB 연결 (update/ delete/ insert)
  2. 같은 전표번호 내에서 차대변 차액 발생하면 차액 표시하는 기능 구현 (전표 소계 열/ 합계 열)
  4. 코드 field에서 F4를 누르면 모달창(계정과목 / 거래처) 띄워주고 데이터받아서 해당 셀의 value값 변경
  5. 날짜 검색 필터
  7. 클릭한 줄과 같은 number field의 값을 가지고 있다면 배경색 강조 표시 (2번과 연결)
  8. 코드 입력하면 계정과목명 / 거래처명 자동 매칭 불러오기
  10. 전표번호 자동부여
  11. 다 하면 자주 사용되는 ag-grid 세팅은 별도의 class만들고 import해서 사용하기
============================================ -->

<head>
  <title>일반전표</title>
</head>
<div layout:fragment="content">
  <div class="w-100" id="account">
    <div class="d-flex justify-content-between align-items-center mb-1">
      <!-- 왼쪽: 일반전표 제목 -->
      <h3 class="mb-0">일반전표</h3>
      <!-- 오른쪽: 버튼 모음 -->
      <div>
        <button class="btn btn-outline-secondary btn-sm" onclick="location.href='/voucher/excel-template'">엑셀 서식 내려받기</button>
        <button class="btn btn-outline-secondary btn-sm" data-bs-toggle="modal" data-bs-target="#excelUploadModal">엑셀 업로드하기</button>
        <button class="btn btn-outline-secondary btn-sm" onclick="deleteSelected()">삭제</button>
        <button class="btn btn-outline-secondary btn-sm" onclick="window.print()">인쇄</button>
      </div>
    </div>
    <!-- 엑셀 업로드 모달 -->
    <div class="modal fade" id="excelUploadModal" tabindex="-1">
      <div class="modal-dialog">
        <form class="modal-content" enctype="multipart/form-data" method="post" action="/voucher/upload">
          <div class="modal-header">
            <h5 class="modal-title">엑셀 업로드</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
          </div>
          <div class="modal-body">
            <input type="file" name="excelFile" accept=".xlsx,.xls" class="form-control">
          </div>
          <div class="modal-footer">
            <button type="submit" class="btn btn-success">업로드</button>
          </div>
        </form>
      </div>
    </div>
    <!-- 검색/필터 영역 -->
    <form class="row g-2 mb-2 align-items-end" method="get" action="/voucher/list">
      <div class="col-auto">
        <label class="form-label mb-0">일자</label>
        2025 년
        <input type="number" class="form-control form-control-sm d-inline-block" name="startMonth" style="width:45px;"> 월
        <input type="number" class="form-control form-control-sm d-inline-block" name="startDay" style="width:45px;"> 일 ~
        2025 년
        <input type="number" class="form-control form-control-sm d-inline-block" name="endMonth" style="width:45px;"> 월
        <input type="number" class="form-control form-control-sm d-inline-block" name="endDay" style="width:45px;"> 일
      </div>
    </form>
    <!-- 본문 ag-Grid -->
    <div class="grid-container" style="height:100vh;">
      <div id="entryGrid" class="ag-theme-alpine" style="width:100%; height:75%;"></div>
    </div>
  </div>
  <script th:inline="javascript">
    // 전체조회 API
    let entryList = /*[[${entryList}]]*/[]; // DB 조회
    console.log(entryList)
    let rowData = []; // 실제 List만들 배열
    entryList.forEach(master => {
      if (master.entryType !== '일반') return; // entryType이 일반이 아닌 것은 건너뜀
      master.details.forEach(detail => {
        rowData.push({
          year: new Date(master.entryDate).getFullYear(),               // 년
          month: new Date(master.entryDate).getMonth() + 1,             // 월
          day: new Date(master.entryDate).getDate(),                    // 일
          entryNumber: master.entryNumber,                              // 전표번호
          resentmenType: detail.resentmenType,                          // 구분
          accountCode: detail.accountCode,                              // 계정코드
          accountName: detail.accountName,                              // 계정과목명
          partnerCode: detail.partnerCode || 0,                         // 코드
          partnerName: detail.partnerName || "",                        // 거래처명
          debit: detail.resentmenType === 'g3' ? detail.amount : 0,     // 차변
          credit: detail.resentmenType === 'g4' ? detail.amount : 0,    // 대변
          description: detail.description                               // 적요
        });
      });
    });
    // rowData 초기값 만들 때 맨 끝에 빈 행 추가
    rowData.push({
      month: '',
      day: '',
      entryNumber: '',
      resentmenType: '',
      accountCode: '',
      accountName: '',
      partnerCode: '',
      partnerName: '',
      debit: 0,
      credit: 0,
      description: ''
    });

    // 필수 값 체크 (입력 및 수정시 사용)
    const requiredFields = new Set(['month', 'day', 'resentmenType', 'accountCode']);
    function isRowValid(rowData, currentField) {
      // 필수 체크 대상이 아닌 필드는 무조건 true
      if (currentField && !requiredFields.has(currentField)) return true;
      // 월 체크
      if (currentField === 'month') return !!rowData.month;
      // 일 체크 (월도 있어야 함)
      if (currentField === 'day') return !!rowData.month && !!rowData.day;
      // 타입 체크
      if (currentField === 'resentmenType') return !!rowData.resentmenType;
      // 계정과목코드 체크
      if (currentField === 'accountCode') return !!rowData.accountCode;
      // 전체 필드 검사 (또는 currentField가 없을 때 전체 검사)
      if (!rowData.month || !rowData.day || !rowData.resentmenType || !rowData.accountCode) return false;
      // 차변 또는 대변 유효성 검사
      const debitValid = rowData.resentmenType !== 'g4' && rowData.debit >= 1;
      const creditValid = rowData.resentmenType !== 'g3' && rowData.credit >= 1;
      if (!debitValid && !creditValid) return false;
      return true;
    }

    // ag-Grid 세팅
    const gridOptions = {
      // 헤더 높이 지정
      headerHeight: 35,
      // 행 높이 지정
      rowHeight: 35,
      // 그리드 values 배열
      rowData: rowData,
      // 그리드 필드명 정의
      columnDefs: [
        { headerName: "월", field: "month", editable: true, minWidth: 55, maxWidth: 55 },
        { headerName: "일", field: "day", editable: true, minWidth: 55, maxWidth: 55 },
        { headerName: "번호", field: "entryNumber", editable: true, minWidth: 75, maxWidth: 75 },
        {
          headerName: "구분", field: "resentmenType", editable: true, minWidth: 70, maxWidth: 70,
          valueFormatter: params => {
            // g1~g4 -> 한글 표시
            const map = { g1: '출금', g2: '입금', g3: '차변', g4: '대변' };
            return map[params.value] || params.value;
          },
          valueParser: params => {
            // 사용자 입력값 숫자 -> g 코드로 변환
            const map = { '1': 'g1', '2': 'g2', '3': 'g3', '4': 'g4' };
            const trim = params.newValue?.toString().trim();
            return map[trim] || params.newValue; // 변환 불가 시 원래값 반환
          },
          valueSetter: params => {
            const map = { '1': 'g1', '2': 'g2', '3': 'g3', '4': 'g4' };
            let newVal = params.newValue;
            if (map[newVal]) newVal = map[newVal];
            if (params.newValue && params.newValue.startsWith('g')) {
              params.data.resentmenType = params.newValue;
              return true; // 허용
            }
            return false; // 변경 거부 (기존 값 유지)
          }
        },
        { headerName: "코드", field: "accountCode", editable: true, minWidth: 70, maxWidth: 70 },
        { headerName: "계정과목", field: "accountName", editable: true, minWidth: 100, maxWidth: 100 },
        { headerName: "코드", field: "partnerCode", editable: true, minWidth: 80, maxWidth: 80 },
        { headerName: "거래처", field: "partnerName", editable: true, initialWidth: 250 },
        {
          headerName: "차변", field: "debit", editable: params => params.data.resentmenType !== 'g4', initialWidth: 135, minWidth: 100, valueFormatter: p => p.value?.toLocaleString(),
          valueSetter: params => {
            const val = Number(params.newValue);
            if (!isNaN(val) && val >= 1) {
              params.data.debit = val;
              return true;
            } else {
              alert("차변은 0 이상의 숫자만 입력 가능합니다.");
              return false; // 입력 거부
            }
          }
        },
        {
          headerName: "대변", field: "credit", editable: params => params.data.resentmenType !== 'g3', initialWidth: 135, minWidth: 100, valueFormatter: p => p.value?.toLocaleString(),
          valueSetter: params => {
            const val = Number(params.newValue);
            if (!isNaN(val) && val >= 1) {
              params.data.credit = val;
              return true;
            } else {
              alert("대변은 0 이상의 숫자만 입력 가능합니다.");
              return false; // 입력 거부
            }
          }
        },
        { headerName: "적요", field: "description", editable: true, minWidth: 400 },
      ],
      // 행 선택 방식을 지정
      rowSelection: {
        mode: 'multiRow', // 'single'==> 단일 선택, 'multiRow' ==> 다중 선택
      },
      onGridReady: (params) => {
        gridOptions.api = params.api; // AG Grid에서 제공하는 API 객체들을 gridOptions에 저장 => 필터나 정렬 등 그리드 조작
      },
      // Enter 키 입력 시 다음 셀로 포커스를 이동하는 로직
      onCellKeyDown: (event) => {
        // Enter 키인지 체크
        if (event.event.key === 'Enter') {
          const api = event.api;
          // 현재 포커스된 행의 인덱스 반환 (전체 행들 중 인덱스)
          const currentRowIndex = event.node.rowIndex;
          // 현재 포커스된 컬럼의 필드명 반환
          const currentCol = event.colDef.field;
          // 전체 columnDefs로부터 현재 컬럼의 인덱스를 찾아냄 (행 내에서 인덱스)
          const allColumns = gridOptions.columnDefs;
          const currentColIndex = allColumns.findIndex(col => col.field === currentCol);
          // 다음 컬럼과 다음 행 인덱스를 계산
          let nextColIndex = currentColIndex + 1; // 다음 셀
          let nextRowIndex = currentRowIndex; // 현재 행

          // 현재 행 유효성 체크
          const currentRowNode = api.getDisplayedRowAtIndex(currentRowIndex);
          // 차변/대변 필드에서 Enter 시 1 이상 값인지 확인
          if (currentCol === 'debit' || currentCol === 'credit') {
            const val = currentRowNode.data[currentCol];
            if (!(val >= 1)) {
              alert("차변/대변 값은 1 이상의 숫자여야 합니다.");
              event.event.preventDefault();
              return;
            }
          }
          // description(적요)로 넘어갈 때는 전체 행 유효성 검사
          if (currentCol === 'description') {
            if (!isRowValid(currentRowNode.data, null)) {
              event.event.preventDefault();
              return;
            }
          } else {
            // description 이외의 컬럼일 때는 해당 컬럼 기준 검사
            if (!isRowValid(currentRowNode.data, currentCol)) {
              event.event.preventDefault();
              return;
            }
          }
          while (true) {
            // 마지막 컬럼이라면 첫번째 컬럼으로 이동하고, 행을 한 줄 내림
            if (nextColIndex >= allColumns.length) {
              nextColIndex = 0;
              nextRowIndex = currentRowIndex + 1; // 현재행 + 1 => 다음행
              // 마지막 행의 마지막 컬럼에서 Enter를 누른 경우 새 행 추가
              if (nextRowIndex >= api.getDisplayedRowCount()) {
                api.applyTransaction({
                  add: [{
                    month: '',
                    day: '',
                    entryNumber: '',
                    resentmenType: '',
                    accountCode: '',
                    accountName: '',
                    partnerCode: '',
                    partnerName: '',
                    debit: 0,
                    credit: 0,
                    description: ''
                  }]
                });
                nextRowIndex = api.getDisplayedRowCount() - 1;
              }
            }

            // editable이 false이면 포커스되지않고 넘어가기 위한 설정
            const nextCol = allColumns[nextColIndex]; // 다음 컬럼
            const nextRowNode = api.getDisplayedRowAtIndex(nextRowIndex); // 현재 행 객체

            // editable 여부 (true | false | 함수)
            let editable = false;
            // 함수면 함수의 결과에 따른 editable를 불러오고, 함수가아니면 editable자체를 그냥 불러오기
            if (typeof nextCol.editable === 'function') { // 다음 컬럼의 editable 타입이 function인지 체크
              editable = nextCol.editable({ data: nextRowNode.data });
            } else {
              editable = nextCol.editable;
            }
            // 불러온 editable의 결과에 따른 처리
            if (editable) {
              break; // 다음행 정상 포커스되도록 index
            } else {
              nextColIndex++; // 다다음행 포커스되도록 index
            }
          }
          // 다음 포커스 잡을 셀로 이동만 하기
          api.setFocusedCell(nextRowIndex, allColumns[nextColIndex].field);
          // 브라우저 기본 Enter 동작 방지
          event.event.preventDefault();
        }
      },
      onCellValueChanged: async (params) => {
        const api = params.api;
        const currentRowIndex = params.node.rowIndex;
        const currentField = params.colDef.field;

        if (currentField === 'partnerCode') {
          const partnerCode = params.newValue;
          params.data.partnerName = '';  // 기본 초기화
          if (partnerCode) {
            try {
              const response = await fetch(`/acc/pt/${partnerCode}`);
              if (response.ok) {
                const partner = await response.json();
                if (partner?.partnerName) {
                  params.data.partnerName = partner.partnerName;
                } else {
                  alert("해당 거래처명을 찾을 수 없습니다.");
                }
              } else {
                alert("거래처 조회 중 오류가 발생했습니다.");
              }
            } catch (e) {
              console.error(e);
              alert("서버와 통신 중 오류가 발생했습니다.");
            }
          }
          api.refreshCells({
            rowNodes: [params.node],
            columns: ['partnerName'],
            force: true
          });
        }

        // 마지막 셀 유지
        const lastRowIndex = api.getDisplayedRowCount() - 1; // 마지막 행의 인덱스 = 행 갯수 - 1
        // 엔터로 다음 셀 이동할 때 마지막 행에서 입력 완료되면
        if (currentRowIndex === lastRowIndex) {
          const lastRowNode = api.getDisplayedRowAtIndex(currentRowIndex);
          if (isRowValid(lastRowNode.data, null)) {
            // 새 빈 행 추가
            api.applyTransaction({
              add: [{
                month: '',
                day: '',
                entryNumber: '',
                resentmenType: '',
                accountCode: '',
                accountName: '',
                partnerCode: '',
                partnerName: '',
                debit: 0,
                credit: 0,
                description: ''
              }]
            });
            // 갱신된 row count
            nextRowIndex = api.getDisplayedRowCount() - 1;
          }
        }

      }
    };
    // 그리드 생성
    agGrid.createGrid(document.querySelector("#entryGrid"), gridOptions);
    // 체크한 행 삭제
    function deleteSelected() {
      // 현재 선택된 행 데이터를 가져오기
      const selectedRows = gridOptions.api.getSelectedRows();
      if (selectedRows.length === 0) {
        alert("삭제할 행을 선택해주세요.");
        return;
      }
      // AG Grid 데이터에서 선택된 행 삭제
      gridOptions.api.applyTransaction({ remove: selectedRows });
    }
    function saveEntries() {
      const allRows = [];
      gridOptions.api.forEachNode(node => {
        allRows.push(node.data);
      });

      for (const row of allRows) {
        if (!isRowValid(row)) {
          alert("필수 값이 누락된 행이 있습니다. 확인해주세요.");
          return;
        }
      }

      console.log("저장될 데이터:", allRows);
    }
  </script>
</div>